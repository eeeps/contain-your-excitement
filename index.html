<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="fonts.css" />
<link rel="stylesheet" href="style.css" />
<script defer src="slideshow.js"></script>
<script defer src="named-element-breakpoints.js"></script>
<link rel="stylesheet" href="prism.css" />
<script defer src="prism.js"></script>
<script defer src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<title>Slides</title>
</head>
<body>

<!--
# TODO

# content

[ ] last slides
[x?] clarify async + why JS over CSS
[ ] modular ilustration
[ ] intro illustration
[ ] make the word "jank" jiggle

## get ready for public access

[ ] incorperate https://github.com/que-etc/resize-observer-polyfill
[ ] figure out some kind of not-secret UI for pageup/pagedown
[ ] intersectionObserver polyfil too, then?

-->

<section id="1" class="title">
	<h1>
		<span>Contain</span>
		<span class="twox" style="display: block; border-top: 1px solid white;">Your Excitement</span>
	</h1>
	<hr style="width: 10em; margin: 0;" />
	<p class="twox center" style="color: var(--light-fg);">
		Eric Portis ★ SmashingConf NYC ★ 2017-06-13
	</p>
</section>

<section class="title" id="2">
	<h1>Who am I?</h1>
	<img src="images/_headshot2.jpg" alt="Headshot" id="headshot"
		style="
			border-radius: 100%;
			border: 0.175em solid var( --light-bg );
			box-shadow: var( --box-shadow );
			margin-top: -0.5em;
			margin-left: 5em;
			width: 4em;
			rotate: 5deg;
		"
	/>
	<div class="layer" id="eric-arrow" style="padding-top: 5em; padding-right: 1em;">
		<img src="images/arrow.svg" alt="arrow" style="height: 2em; padding-left: 0.25em;" />
		<p
			class="thin"
			style="
				text-transform: uppercase;
				rotate: -5deg;
				font-size: 1.25em;
				margin-top: -0.05em;
			"
		>
			Eric!
		</p>
	</div>
	<aside class="notes">


The notes go here.

Do carriage returns work?

I wonder.

	</aside>
	<script>
		var section = document.currentScript.parentNode;
		
		section.init = ( ( section ) => {
			section.elementsToReveal = [
				section.querySelector( '#headshot' ),
				section.querySelector( '#eric-arrow' )
			]
			for ( element of section.elementsToReveal ) {
				element.classList.add( 'hidden' );
			}
		} );
		
		section.events = [
			{
				do: ( section ) => {
					for ( element of section.elementsToReveal ) {
						element.classList.remove( 'hidden' );
					}
				},
				undo: ( section ) => {
					for ( element of section.elementsToReveal ) {
						element.classList.add( 'hidden' );
					}
				}
			}
		];
	</script>
</section>

<section class="whatido" style="align-content: stretch;">
<style>
.whatido ul {
	list-style: none;
	display: flex;
	flex-direction: column;
	justify-content: space-around;
	height: 100%;
	padding-bottom: 10vh;
	padding-top: 10vh;
}
.whatido .what {
	font-family: SooperSerifThinCondensed2x;
	text-transform: uppercase;
	font-size: 1.5em;
	display: block;
}
.whatido .where {
	color: var(--light-fg);
	font-size: 0.75em;
	display: block;
}
</style>
<ul>
<li><span class="what">Developer Advocate</span> <span class="where">@ Cloudinary</span></li>
<li><span class="what">Hanger-on</span> <span class="where">@ Responsive Issues Community Group</li>
<li><span class="what">Lapsed printmaker-photographer</span> <span class="where">@ Remote Island in Puget Sound</li>
</ul>
<aside class="notes">
Developer Evangelist at Cloudinary, which is an image back-end for web and mobile developers. We help you manage image upload, storage, manipulation, and delivery. If you work with images, especially responsive images, like the ones I’ll be talking about tonight — Cloudinary can help you do that work better.

Before I worked at cloudinary, I managed the web store of a tiny fine art print shop in Denver Colorado… and got *really* upset with the way images worked within responsive layouts… yadda yadda yadda, I was spending hours in WHATWG mailing lists and writing a weekly newsletter for the responsie images community group, which spec’d and implemented the features I’m going to be talkign about today

I still like art, and I live on an island now where I kind of wander around and take weird infared photographs of kelp and things…
the island is called orcas island ; if any of you are ever out in the san juans ; it’s beautiful and you should all come visit

but enough about me
</aside>
</section>

<section id="2" class="title">
	<h1>Element queries!</h1>
	<div class="layer">
		<p class="sticker" style="
			position: relative;
			left: -3.33rem;
			top: -0.125em;
			margin-top: -2px;
			font-size: 1.33em;
		">
			Container?
		</p>
	</div>
	<aside class="notes">
Let’s talk about element queries!

[click]

Or container queries, or whatever.
I suppose a brief note on terminology is in order
	</aside>
	<script>
		var section = document.currentScript.parentNode;

		section.init = ( ( section ) => {
			section.stickerLayer = section.querySelector( '.layer' );
			section.stickerLayer.classList.add('hidden');
		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.stickerLayer.classList.remove('hidden');
				},
				undo: ( section ) => {
					section.stickerLayer.classList.add('hidden');
				}
			}
		];
	</script>
</section>

<section class="center">
<p style="font-size: 1.5em;">“Element?” “Container?”</p>
<h1 style="margin-top: 0.25em;">Same-same.</h1>
<aside class="notes">
We’ll get into the distinction between “element” and “container” queries a bit later, but for the first part of this talk, I and some folks that I’ll be quoting will use the terms more or less interchangably.
</aside>
</section>


<section class="center">
<h1 style="margin-top: 0.25em;">= media queries for elements</h1>
<aside class="notes">
And I’ll be using the terms to refer to an idea. In a nutshell: we should be able to adapt element’s styles based on their own state. Not just the state of the entire viewport.
</aside>
</section>


<section id="2">
	<h1>Media queries are a whole-viewport-solution...</h1>
	<p>...designed to solve whole-document problems.</p>
	<aside class="notes">
It’s worth taking a moment to think about about where Media Queries came from.

How many of are old enough to have written a print-specific stylesheet?
	</aside>
</section>


<section id="3" class="code">

<div style="height: 4rem;">
	<pre class="before"><code class="language-html">
	&lt;link rel="stylesheet" type="text/css" 
		media="print" href="serif.css"&gt;
	&lt;link rel="stylesheet" type="text/css" 
		media="screen" href="sans-serif.css"&gt;
	</code></pre>

	<pre class="after"><code class="language-css">
	@media print {
		* { font-family: serif }
	}
	@media screen {
		* { font-family: sans-serif }
	}
	</code></pre>

	<pre class="afterafter"><code class="language-css">
	@media screen and (min-width: 400px) {
		...
	}
	</code></pre>
</div>

<footer><p>Example from <a href="https://www.w3.org/TR/2001/WD-css3-mediaqueries-20010404/">the original Media Queries specification</a>, published in 2001.</p></footer>

<aside class="notes">
Well the original media queries spec, piblished sixteen years ago, opens with the following example. This is something that I’m just barely old enough to remember. But ten or twenty years ago, it was not unheard of for webmasters to provide one style sheet for screens, and a completely different stylesheet for print, containing page styles tailored for 8.5x11, high-resolution, black-and-white, laser-printed pieces of good-old-fashioned paper.

The media queries spec says, hey, this is a decently common use case -- how about we let you wrap these two sets of styles up into the same stylesheet, like this [click]. Media queries let you wrap your media-specific styles in a little @media block -- no separate stylesheet required.

As luck would have it, the spec authors also decided that, as long as they were letting you query media *types*, why not also let you query specific media *features*, say, width? [click]

And just like that, the media queries we all know and love -- along with so much of what we now call "responsive design" -- was born.
</aside>

	<script>
		var section = document.currentScript.parentNode;

		section.init = ( ( section ) => {
			section.before = section.querySelector( '.before' );
			section.after = section.querySelector( '.after' );
			section.afterafter = section.querySelector( '.afterafter' );
			section.after.style.display = 'none';
			section.afterafter.style.display = 'none';
		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.after.style.display = 'block';
					section.before.style.display = 'none';
				},
				undo: ( section ) => {
					section.after.style.display = 'none';
					section.before.style.display = 'block';
				}
			},
			{
				do: ( section ) => {
					section.after.style.display = 'none';
					section.afterafter.style.display = 'block';
				},
				undo: ( section ) => {
					section.after.style.display = 'block';
					section.afterafter.style.display = 'none';
				}
			}
		];
	</script>

</section>

<section class="center">

<!--TODO-->
<img alt="scaling page with big word that changes from small to big" />
<!--change to-->
<img alt="scaling page full of individual components that all have their own small/big changes at different points" />
<h1><del>Responsive pages</del><ins>Modular components</ins></h1>

<aside class="notes">
And, when we we’re designing web pages, and we want to adapt those pages in response to facts about the whole viewport, they’re a great solution.

But increasingly, we’re not really designing monolithic *pages*. We’re designing modular *components*. And what we want, is the ability to set breakpoints directly on those components.

Whether you’re working with Web Components, React components, <a href="http://atomicdesign.bradfrost.com/chapter-2/">Brad’s Atomic Design elements</a>, <a href="https://smacss.com/book/type-module">SMACSS modules</a> or Object-OrientedCSS objects or BEM blocks, <a href="http://styleguides.io/">style-guides and pattern libraries</a>, or even just <a href="https://adactio.com/journal/4523">the high-level notion that we should be designing from our content, out, rather than the page’s frame, in</a> – media queries are a kludge and, in the words of Ian Storm Taylor, <a href="https://ianstormtaylor.com/media-queries-are-a-hack/">a hack</a>.

</aside>
</section>


<section id="eq-example" class="code">
<div class="example-container">
	<div class="resizable example-viewport" id="example_1495648141">
		<style>
			#example_1495648141 .container {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(1px, 1fr));
				grid-gap: var(--margin);
				margin: var(--margin);
			}
			#example_1495648141 .block {
				--named-breakpoints: 2.25em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				background-color: lightblue;

			}
			#example_1495648141 .block.make-it-pink {
				background-color: deeppink;
			}

		</style>
		<div class="container">
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
		</div>
	</div>
</div>
<pre style="margin-bottom: -1.25em;"><code class="language-css">
.block {
	background-color: lightblue; 
}
</code></pre>
<pre class="mediaquery" style="height: 8em;"><code class="language-css">
@media (min-width: 797px) {
	.block {
		background-color: deeppink;
	}
}
</code></pre>
<pre class="elementquery" style="height: 8em;"><code class="language-css">
.block:min-width(100px) {
	background-color: deeppink;
}
</code></pre>
	<script>
	var section = document.currentScript.parentNode;

	section.init = ( ( section ) => {
		section.mediaquery = section.querySelector( '.mediaquery' );
		section.elementquery = section.querySelector( '.elementquery' );
		section.mediaquery.classList.add( 'hidden' );
		section.elementquery.classList.add( 'none' );
		section.container = section.querySelector( '.container' );
		section.lastDiv = section.container.querySelector('.block:last-child');
	} );
	
	section.events = [
		{ // show the media query
			do: ( section ) => {
				section.mediaquery.classList.remove( 'hidden' );
			},
			undo: ( section ) => {
				section.mediaquery.classList.add( 'hidden' );
			}
		},
		{ // increase the margin
			do: ( section ) => {
				section.container.style.margin = 'var(--margin) calc( var(--margin) / 4 )';
				section.container.style.gridGap = 'calc( var(--margin) / 4 )';
			},
			undo: ( section ) => {
				section.container.style.margin = 'var(--margin)';	
				section.container.style.gridGap = 'var(--margin)';
			}
		},
		{
			do: ( section ) => {
				section.container.removeChild(section.lastDiv);
			},
			undo: ( section ) => {
				section.container.appendChild(section.lastDiv);
			}
		},
		{
			do: ( section ) => {
				section.mediaquery.innerHTML = 
				 section.mediaquery.innerHTML.replace('797px', '582px');
			},
			undo: ( section ) => {
				section.mediaquery.innerHTML = 
				 section.mediaquery.innerHTML.replace('582px', '797px');
			}
		},
		{
			do: ( section ) => {
				section.mediaquery.classList.add('none');
				section.elementquery.classList.remove('none');
			},
			undo: ( section ) => {
				section.mediaquery.classList.remove('none');
				section.elementquery.classList.add('none');
			}
		}		
	];
	</script>
	<aside class="notes">
An example’s in order. Let’s say I've got a line of five little light-blue flexible components, like this.

And let’s say that when these boxes get to be 100px wide, I want to change them in some way – lets say I want to make them pink.

So, I'll write a media query. I'll figure out how wide the entire viewport is, just as each element hits 100px-wide. And use that whole viewport width as my min-width, like this [click]

Now what I’ve done here, that’s kludgy and bad, is bake a bunch of external state into what should just be a statement about the boxes. Remember, all I care about is the width the boxes. If they’re at least 100px wide, make them pink. But now I'm in a situation where, if many things *around* the boxes change -- let's say I tweak my margins [click], or change the number of boxes [click] -- The media query no longer does what I want, and I’ll have to change it. [click] That's bad!

What I really want to be able to say, here, is say exactly what I mean. When these specific *elements* are at least 100px wide, turn them pink. Like this [click].

That's an element query.
	</aside>
</section>

<!--
<section>
<h1 class="center">Pretty neat!</h1>
<p>Now show me something useful?</p>
</section>


<section id="5">
<h1>Other use cases</h1>
<ul>
	<li>interactive content</li>
	<li>modular components!</li>
	<li>any kind of content-out (rather than viewport-in) design</li>
</ul>
<aside class="notes">
Interactive content
Best example, this slide deck right here?
toolbars that fly out, resize in response to user input

Modular components
React... Atomic design, pattern libraries
legos

Content-out design
Even if you’re designing static pages full of one-off design work, even if you don't care about modular reusable components at all
Any time you're design from the content, out, rather than from page dimension and a given set of breakpoints, in -- you want element queries.
- point back to weather widgets
- mobile first, stretch it till it breaks, set a break point
- dont want to have to re-write those breakpoints later, because some other part of the page changed
</aside>
</section>
-->


<section id="tweets" class="title">
<h1>People have been asking</h1>
<p>for element queries</p>
<aside class="notes">
And hoo boy, have people been asking for them.
</aside>
</section>

<section class="center">
<figure>
<img src="images/ResponsiveContainersScrenshot.png" alt="A screenshot of http://blog.andyhume.net/responsive-containers/"  style="max-height: 65vh;" />
<figcaption>
<p><cite><a href="http://blog.andyhume.net/responsive-containers/">Responsive Containers</a></cite> by Andy Hume</p>
</figcaption>
</figure>
<aside class="notes">
Here’s the first mention I that could find of the general concept – an clear, concise, and six-year-old blog post from Andy Hume, complete with a working, javascript-based implementation and demo of the idea. Andy called them “Selector Queries”. 
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">We need native CSS media queries at the element/component/widget level, not just the viewport. Make it so, internetz.</p>&mdash; Nicolas (@necolas) <a href="https://twitter.com/necolas/status/299573744307941376">February 7, 2013</a></blockquote>
<aside class="notes">
Turns out, they were a good idea...
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Great read about the #1 missing tool for responsive design: Element queries  <a href="http://t.co/EARts4HWWr">http://t.co/EARts4HWWr</a> (viewport queries are still valuable)</p>&mdash; Brad Frost 🇺🇸 (@brad_frost) <a href="https://twitter.com/brad_frost/status/319929504422322176">April 4, 2013</a></blockquote>
<aside class="notes">
...it wasn’t too long before some of the smartest minds in the industry were calling element-level queries “the number one missing tool for responsive design.”
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Ahh, Spring—when a young man’s fancy turns to thoughts of element queries, what that syntax might look like, and how one might prototype it.</p>&mdash; Mat Marquis (@wilto) <a href="https://twitter.com/wilto/status/466673241130430464">May 14, 2014</a></blockquote>
<aside class="notes">
By 2014, serious efforts were underway to turn what had been just an exciting idea into an empowering reality.

But. There were problems. More on those later.

For now, I just want to take you on a journey of increasingly sad and desparate tweets.
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Monthly tweet about how _super_ helpful natively supported element queries would be.</p>&mdash; Tim Kadlec (@tkadlec) <a href="https://twitter.com/tkadlec/status/493849870554259457">July 28, 2014</a></blockquote>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Why element queries?<br><br>Less CSS to write, more modular &amp; maintainable CSS/HTML, smarter responsive images, web components, etc.</p>&mdash; Tim Kadlec (@tkadlec) <a href="https://twitter.com/tkadlec/status/493852410700247041">July 28, 2014</a></blockquote>
<aside class="notes">
It starts innocently enough, with earnest pleas and sound arguments.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Coulda used ElementQueries about 45 times today.</p>&mdash; Dave Rupert (@davatron5000) <a href="https://twitter.com/davatron5000/status/558402932509401088">January 22, 2015</a></blockquote>
<aside class="notes">
But by 2015, impatience started to set in.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Does anyone know what the current state of <a href="https://twitter.com/hashtag/CSS?src=hash">#CSS</a> Element Queries is? Any updates on whether cyclic dependency can be solved/worked around?</p>&mdash; Sara Soueidan 🐦 (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/594947884090429440">May 3, 2015</a></blockquote>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">If I had to choose only one new CSS feature to be implemented asap, it would be container queries. So much NEED. <a href="https://twitter.com/hashtag/respond16?src=hash">#respond16</a></p>&mdash; Sara Soueidan 🐦 (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/718308762033987584">April 8, 2016</a></blockquote>

<aside class="notes">
Front end developers began do wonder... is anyone listening?
</aside>
</section>

<section>
<!--<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Serious question: where are element queries at? Any updates since the last “they cause a loop so we have to figure out how to do this” one?</p>&mdash; Sara Soueidan 🐦 (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/807982469714706434">December 11, 2016</a></blockquote>-->

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">All I want in 2017 on the Web is Container Queries. Seriously.</p>&mdash; Sara Soueidan 🐦 (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/812333338744721408">December 23, 2016</a></blockquote>
<aside class="notes">
How many times do we have to say it?
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">hypothesis<br><br>If element queries were real, over 50% of the media queries we write would be element queries.</p>&mdash; Chris Coyier (@chriscoyier) <a href="https://twitter.com/chriscoyier/status/668796363900100613">November 23, 2015</a></blockquote>
<aside class="notes">
Doesn’t anybody understand what a big deal element queries would be?
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I wonder when and if we’ll ever get Container Queries in CSS. It’s only possibly the most useful RWD technique. The wait is depressing.</p>&mdash; Sara Soueidan 🐦 (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/744117584941875200">June 18, 2016</a></blockquote>
<aside class="notes">
Evidently, they don't. Diffrent developers have responded to this differently. Sadness is a common reaction.
</aside>
</section>

<!--
<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">That time of day when you run into a CSS layout that’s going to be a total hack job to build without element/container queries.</p>&mdash; Scott Jehl (@scottjehl) <a href="https://twitter.com/scottjehl/status/723575660065726465">April 22, 2016</a></blockquote>
<aside class="notes">
A certain fatalism began to creep into the conversation.
</aside>
</section>
-->

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">are container queries here yet<br><br>dot tumblr dot corn</p>&mdash; Ethan Marcotte (@beep) <a href="https://twitter.com/beep/status/723156713373732865">April 21, 2016</a></blockquote>
<aside class="notes">
Others have resorted to dry humor.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">FUTURE BROWSER v154.2 release notes<br>* JS engine optimizations—technically now a time machine<br>* nothing on container queries yet—stop asking</p>&mdash; Zach Leatherman (@zachleat) <a href="https://twitter.com/zachleat/status/748241672757084160">June 29, 2016</a></blockquote>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">The fact that we’ll probably get stable, cross browser WebVR before container queries is a good example of what’s wrong with our industry.</p>&mdash; Zach Leatherman (@zachleat) <a href="https://twitter.com/zachleat/status/790926735156011008">October 25, 2016</a></blockquote>
<aside class="notes">
Bitterness (you know, sometimes the saddest tweets are the truest tweets...)
</aside>
</section>


<section>
<div  style="zoom: 0.75;">
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Well, I tried. <a href="https://t.co/mCfx2Tor0O">pic.twitter.com/mCfx2Tor0O</a></p>&mdash; Zach Leatherman (@zachleat) <a href="https://twitter.com/zachleat/status/743219273275826176">June 15, 2016</a></blockquote>
</div>
<aside class="notes">
And desperate cries for help
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="und" dir="ltr">I want my <br>element <br>element<br>element<br>I want my element<br>element<br>element<br>element<br>Chilis element queries, Chilis element queries<br>barbecue sauce</p>&mdash; Brad Frost 🇺🇸 (@brad_frost) <a href="https://twitter.com/brad_frost/status/765926034604695552">August 17, 2016</a></blockquote>
<aside class="notes">
Some, sadly, have been driven to madness.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Be our witness? <a href="https://twitter.com/chriscoyier">@chriscoyier</a> and I just bet $20 that element queries would get implemented. I said no, he said yes. :)</p>&mdash; Nicole Sullivan (@stubbornella) <a href="https://twitter.com/stubbornella/status/611925043950538753">June 19, 2015</a></blockquote></script>
<aside class="notes">
My favorite response might be Nicole Sullivan's. Nicole thought, well, if I can't have element queries, at least I can have $20!
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/grigs">@grigs</a> DO CONTAINER QUERIES NEXT <a href="https://t.co/fVT8NXGnqQ">pic.twitter.com/fVT8NXGnqQ</a></p>&mdash; Ethan Marcotte (@beep) <a href="https://twitter.com/beep/status/862791570826960896">May 11, 2017</a></blockquote>
<aside class="notes">
For those who, in 2017, still nurture hope, the message is loud and clear
</aside>
</section>

<section id="notyet" class="title">
<h1>What’s the hold up?</h1>
<aside class="notes">
</aside>
</section>

<section>
<p>Please excuse a wildly simplified explanation of</p>
<h1>the rendering pipeline</h1>
<aside class="notes">
</aside>
</section>

<section id="how-browsers-work">
	<object type="image/svg+xml" data="images/how-browsers-work.svg" style="grid-column: 1 / 4; width: 100vw; height: 100vh;" onload="
		let s = this.parentElement;
		s.svg = this.getSVGDocument();
		s.html = s.svg.getElementById('HTML'),
		s.css = s.svg.getElementById('CSS'),
		[
			s.dom = s.svg.getElementById('DOM'),
			s.cssom = s.svg.getElementById('CSSOM'),
			s.renderTree = s.svg.getElementById('Render-Tree'),
			s.boxTree = s.svg.getElementById('Box-Tree'),
			s.pixelsOnScreen = s.svg.getElementById('Pixels-on-screen'),
			// s.loadAndParse = s.svg.getElementById('Load-and-Parse'),
			s.loadAndParseTopArrow = s.svg.getElementById('Load-and-Parse-top-arrow'),
			s.loadAndParseBottomArrow = s.svg.getElementById('Load-and-Parse-bottom-arrow'),
			s.loadAndParseText = s.svg.getElementById('Load-and-Parse-text'),
			s.runSelectors = s.svg.getElementById('Run-Selectors'),
			s.layout = s.svg.getElementById('Layout'),
			s.paint = s.svg.getElementById('Paint'),
			s.elementQueries = s.svg.getElementById('ELEMENT-QUERIES')
		].forEach( ( element ) => {
			element.classList.add('none');
		} );
	">
	 A big ol' diagram
	</object>
	<aside class="notes">
	</aside>
	<script>
		var section = document.currentScript.parentNode;
		
// 		section.init = ( ( section ) => {
// 			section.object = section.querySelector('object');
// 			section.svg.addEventListener( 'load', () => {
// 				section.svg = section.querySelector('object').getSVGDocument();
// 			} );
// 			// section.html = section.svg.getElementById('HTML');
// 			// section.html.setAttribute('visibility', 'hidden');
// 		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.loadAndParseText.classList.remove('none');
				},
				undo: ( section ) => {
					section.loadAndParseText.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.loadAndParseTopArrow.classList.remove('none');
				},
				undo: ( section ) => {
					section.loadAndParseTopArrow.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.dom.classList.remove('none');
				},
				undo: ( section ) => {
					section.dom.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.loadAndParseBottomArrow.classList.remove('none');
				},
				undo: ( section ) => {
					section.loadAndParseBottomArrow.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.cssom.classList.remove('none');
				},
				undo: ( section ) => {
					section.cssom.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.runSelectors.classList.remove('none');
				},
				undo: ( section ) => {
					section.runSelectors.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.renderTree.classList.remove('none');
				},
				undo: ( section ) => {
					section.renderTree.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.layout.classList.remove('none');
				},
				undo: ( section ) => {
					section.layout.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.boxTree.classList.remove('none');
				},
				undo: ( section ) => {
					section.boxTree.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.paint.classList.remove('none');
				},
				undo: ( section ) => {
					section.paint.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.pixelsOnScreen.classList.remove('none');
				},
				undo: ( section ) => {
					section.pixelsOnScreen.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.elementQueries.classList.remove('none');
				},
				undo: ( section ) => {
					section.elementQueries.classList.add('none');
				}
			}
		];
	</script>
</section>



<section>
	<p class="bigemoji center">🔁</p>
	<p>Problem #1:</p>
	<h1>Circularity</h1>
</section>

<section class="code" id="circular-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496355733">
		<style>
			#example_1496355733 .block {
				margin: var(--margin);
				--named-breakpoints: 10em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				width: calc( 100% - var(--margin) * 2 );
				background-color: lightblue;
			}
			#example_1496355733 .block.make-it-pink {
				width: 5em;
			}

		</style>
		<div class="block"></div>
	</div>
</div>
<pre><code class="language-css">
.block:min-width(10em) {
	width: 5em;
}
</pre></code>
</section>

<section class="code" id="one-way-adaptation-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496382980">
		<style>
			#example_1496382980 .container {
				margin: 0 calc(var(--margin) / 2);
				display: flex;
			}
			#example_1496382980 .block {
				margin: var(--margin) calc(var(--margin) / 2);
				--named-breakpoints: 3em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				width: calc( 100% - var(--margin) * 2 );
				background-color: lightblue;
			}
			#example_1496382980 .block.make-it-pink {
				border: 0.25em solid deeppink;
			}

		</style>
		<div class="container">
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
		</div>
	</div>
</div>
<pre><code class="language-css">
.container {
	display: flex;
}

.block:min-width(3em) {
	border: 0.25em solid deeppink;
}
</pre></code>
</section>



<section class="code" id="one-way-adaptation-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496381020"
	     style="width: 7.87em;">
		<style>
			#example_1496381020 .container {
				margin: 0 calc(var(--margin) / 2);
				display: flex;
			}
			#example_1496381020 .block {
				margin: var(--margin) calc(var(--margin) / 2);
				--named-breakpoints: 3.25em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				width: calc( 100% - var(--margin) * 2 );
				background-color: lightblue;
				padding: 0.125em;
				font-family: 'SooperSerifThinCondensed';
				font-size: 0.75em;
			}
			#example_1496381020 .block.make-it-pink {
				letter-spacing: 0.1em;
			}

		</style>
		<div class="container">
			<div class="block">Super</div>
			<div class="block">califragilistic</div>
			<div class="block">expiali</div>
			<div class="block">docious</div>
		</div>
	</div>
</div>
<pre><code class="language-css">
.container {
	display: flex;
}

.block:min-width(3.25em) {
	letter-spacing: 0.1em;
}
</pre></code>
</section>

<section class="center">
	<h1>Element Queries</h1>
	<div class="layer">
		<p class="sticker" style="
			position: relative;
			left: -2.5rem;
			top: -0.125em;
			margin-top: -2px;
			background-color: var(--dark-bg);
		">
			Container!
		</p>
	</div>
	<script>
		var section = document.currentScript.parentNode;
		
		section.init = ( ( section ) => {
			section.stickerLayer = section.querySelector( '.layer' );
			section.stickerLayer.classList.add('hidden');
		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.stickerLayer.classList.remove('hidden');
				},
				undo: ( section ) => {
					section.stickerLayer.classList.add('hidden');
				}
			}
		];
	</script>
</section>


<section class="code" id="circular-container-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496356616">
		<style>
			#example_1496356616 .wrapper {
				--named-breakpoints: 10em make-it-pink;
				margin: var(--margin);
				border: 0.0625em solid deeppink;
			}
			#example_1496356616 .block {
				height: calc( var(--height) - var(--margin) * 2 - 0.125em );
				background-color: lightblue;
			}
			#example_1496356616 .wrapper.make-it-pink > .block {
				width: 5em !important;
			}

		</style>
		<div class="wrapper">
			<div class="block"></div>
		</div>
	</div>
</div>
<pre><code class="language-css">
.wrapper {
	border: 0.0625em solid deeppink;
}

.block:container(width > 10em) {
	width: 5em;
}
</code></pre>

<div class="poo layer">
<img style="width:7.5em;" src="images/pile-of-poo.png" alt />
</div>

<script>
	var section = document.currentScript.parentNode;

	section.init = ( ( section ) => {
		section.codeEl = section.querySelector("code.language-css");
		section.wrapper = section.querySelector(".wrapper");
		section.block = section.querySelector(".block");
		section.poo = section.querySelector(".poo");
		section.poo.classList.add('hidden');
		section.codeElContents = [
			section.codeEl.textContent,
			".wrapper {\n\
	border: 0.0625em solid deeppink;\n\
	float: left;\n\
}\n\
\n\
.block:container(width > 10em) {\n\
	width: 5em;\n\
}",
			".wrapper {\n\
	border: 0.0625em solid deeppink;\n\
	float: left;\n\
}\n\
\n\
.block {\n\
	width: 11em;\n\
}\n\
\n\
.block:container(width > 10em) {\n\
	width: 5em;\n\
}"
		];
	} );
	
	section.events = [
		{
			do: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 1 ], Prism.languages.css);
				section.wrapper.style.float = 'left';
				
			},
			undo: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 0 ], Prism.languages.css);
				section.wrapper.style.float = 'none';
			}
		},
		{
			do: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 2 ], Prism.languages.css);
				section.block.style.width = "11em";
			},
			undo: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 1 ], Prism.languages.css);
				section.block.style.width = "100%";
			}
		},
		{
			do: ( section ) => {
				section.poo.classList.remove( 'hidden' );
			},
			undo: ( section ) => {
				section.poo.classList.add( 'hidden' );
			}
		}
	];
</script>

</section>

<section>
<h1>Two solutions...</h1>
</section>

<section>
<h1><span style="font-family: SooperSerifThinCondensed2x;">(closest)</span> Container <span style="font-family: SooperSerifThinCondensed2x;">(whose width is not influenced by its children)</span> Queries</h1>
</section>

<section>
<img src="images/cq-prolyfill.png" alt="screenshot of Martin Auswoger’s blog post about container query solutions" style="height: 60vh; margin: -0.5em auto 0.5em auto;" />
<p>Conceived of + implemented by Martin Auswoger</p>
<footer>
<p><a href="https://github.com/ausi/cq-prolyfill">https://github.com/ausi/cq-prolyfill</a> + <a href="https://au.si/css-container-element-queries">https://au.si/css-container-element-queries</a></p></footer>
</section>

<section>
<img src="images/css-containment.png" style="height: 60vh;" alt="screenshot of the CSS Containment Module Level 1 draft" />
<h1><code class="language-css">contain: strict;</code></h1>
<footer><p><a href="https://drafts.csswg.org/css-contain/">https://drafts.csswg.org/css-contain/</a></p></footer>
</section>

<section>
	<p class="bigemoji center">🏚</p>
	<p>Problem #2:</p>
	<h1>Breaks layout engine architecture</h1>
	<aside class="notes">
	Remember our diagram from earlier? For twenty years, browsers have been following that path from left, to right, in a single pass.
	
	Even if we can solve the problem of infinite loops -- a giant backwards arrow and, finite trips around the loop are still problematic. Especially when browsers assume and have always assumed that we can figure out which styles apply to what elements BEFORE we know how large those elements are.
	</aside>
</section>



<section>

<div style="zoom: 0.8;" />
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Currently selectors are run and styles computed independently, and before, layout. They&#39;re separate layers.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818560290224619520">January 9, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Layout engine architecture is currently designed around this split.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818561591427801088">January 9, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Changing that would require major high level architectural work in all engines.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818561896961802240">January 9, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Which isn&#39;t impossible, but certainly isn&#39;t going to be easy.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818562265574084608">January 9, 2017</a></blockquote>
</div>

<aside class="notes">
Nicely summarized by Erika ETODO, aka fantasai, of CSS Working Group fame, in response to a question asked by none other than Sarah, about what it would take for Container queries to become a thing.


</aside>
</section>

<section>
<blockquote class="mailing-list">
<pre>
<span class="meta">On Thu, 21 Mar 2013 at 3:08 PM, <a href="https://lists.w3.org/Archives/Public/www-style/2013Mar/0403.html">Elliott Sprehn wrote</a>:</span>

<span class="meta">&gt;</span> This doesn't seem very easy to implement because <em>it breaks the sequential</em>
<span class="meta">&gt;</span> <em>processing model</em>:
<span class="meta">&gt;</span> 
<span class="meta">&gt;</span> 1. resolve style on elements such that you have a flattened set of
<span class="meta">&gt;</span> properties.
<span class="meta">&gt;</span> 2. layout the elements if things are different then the last time we did
<span class="meta">&gt;</span> step 1.

<span class="meta">&gt;</span> <em>This would be a big undertaking in Webkit so I don't think it falls</em>
<span class="meta">&gt;</span> <em>anywhere in the near future.</em>


<span class="meta">On Thu, Mar 21, 2013 at 6:34 PM, <a href="https://lists.w3.org/Archives/Public/www-style/2013Mar/0421.html">Elliott Sprehn wrote</a>:</span>

<span class="meta">&gt;</span> I think there's a high implementation cost for this kind of thing

<span class="meta">&gt;</span> <em>It certainly could be done given enough time and someone very</em>
<span class="meta">&gt;</span> <em>motivated...</em>
</pre>
</blockquote>

<aside class="notes">
And here’s Elliott Sprehn, WebKit implementor, saying the same thing on the www-style mailing list.

Container queries would be an unusually large amount of work, for implementors.

As we’ve seen, they’re’s also been an extraordinary amount of demand for them, from authors.

So we’ve got an unstoppable force, which is authors working with components in responsive designs, yearning for container queries — meeting an immovable object, which is 20 years of tightly-optimized code in browsers, whose fundamental architectural assumptions, container queries would break.

What happens when those things collide?
</aside>
</section>

<section>
	<blockquote>
	<img src="images/priority-of-constituencies.png" alt="Section 3.2 of the HTML design principles, which reads, “In case of conflict, consider users over authors over implementors over specifiers over theoretical purity.”" />
	<footer>—<cite><a href="https://www.w3.org/TR/html-design-principles/#priority-of-constituencies">HTML Design Principles</a></cite></footer>
	</blockquote>
	<aside class="notes">
	Luckily, we have this passage the HTML design principles to guide us through it. The priority of constituencies, which states that...
	
	This is a beautiful statement, which, at multiple levels, implores the powerful few to understand and serve the relative many, who must live with the products and consequences of their work.

	Also, it means, we win, right!? Authors over implementors! That means if we 
	want container queries, but implementors think they’re really hard or whatever – too bad! quit your bitchin’ and start re-architectin’!
	
	But. In this hierarchy. There is one constituency whose concerns can, and should, matter more than ours. [click] Users. Which brings us to the last, biggest, and best reason that Container Queries aren’t a thing yet.
	</aside>
	<script>
	var section = document.currentScript.parentNode;

	section.init = ( ( section ) => { 
		section.screenshot = section.querySelector('img');
		section.srcs = [
			section.screenshot.src,
			'images/authors-over-implementors.png',
			'images/users-over-authors.png'
		];
	} );
	
	section.events = [
		{
			do: ( section ) => {
				section.screenshot.src = section.srcs[1];
			},
			undo: ( section ) => {
				section.screenshot.src = section.srcs[0];
			}
		},
		{
			do: ( section ) => {
				section.screenshot.src = section.srcs[2];
			},
			undo: ( section ) => {
				section.screenshot.src = section.srcs[1];
			}
		}
	];
	</script>
</section>


<section>
	<p class="bigemoji center">🐌</p>
	<p>Problem #3:</p>
	<h1>Fundamentally slow</h1>
	<aside class="notes">

	</aside>
</section>

<section>
	<p class="bigemoji center">🐇</p>
	<p>...and it needs to be FAST</p>
	<aside class="notes">
Paint happens at the refresh rate of the display -- usually 60 times per second.
	</aside>
</section>

<section>
<h1 style="text-align: center; "><span style="font-size: 10rem; display: block; margin-bottom: -1.75rem;">16</span> milliseconds</h1>
<aside class="notes">
That means we have to complete all of our layout and paint work -- along with whatever javascript might get thrown into the mix -- once every 16 seconds. Especially on low-powered mobile devices, every one of those milliseconds is precious. 
	</aside>
</section>

<section class="center">
	<img src="images/smashingconf.png" alt="A screenshot of smashingconf.com with the dev tools open" style="height: 11em;" />
	<p style="margin-top: -0.5em;">5ms best / 35ms worst</p>
	<aside class="notes">
Let me give you a high-level sense of what that number means... My computer is not a low-powered mobile device, it’s a 15" macbook pro.

And when I load a fairly simple, well-architected, responsive page that uses media queries, like, say SmashingConf.com, and measure the perf of the site while I resize the window a bunch, I can drill down into the dev tools and see that, most of these frames are happening right on schedule at 60FPS. And most of the time between frames is idle, too – the browser is spending about 5-ish ms re-figuring layout and re-painting in response to the changing window size, but it has 10-ish ms to spare.

We do actually drop a couple of frames every once and a while -- it looks here like I hit a major breakpoint right at the end of a 16ms beat here, and the browser had to spend a chunk of time calculating and painting the new, significantly different layout, and we ended up missing a couple of frames... bad luck, but still, visually, the experience of resizing this page is seamless.

So that gives you a little bit of a sense, maybe of the baseline we're working with - of what that 16ms budget actually means, in practice.
	</aside>
</section>

<section>
	<object type="image/svg+xml" data="images/how-browsers-work.svg" style="grid-column: 1 / 4; width: 100vw; height: 100vh;" onload="
	// change “element” to “container”
	let svg = this.getSVGDocument();
	let elQ = svg.getElementById('element-queries-text');
	let coQ = svg.getElementById('container-queries-text');
	elQ.classList.add( 'none' );
	coQ.classList.remove( 'none' );
	">
	 A big ol' diagram
	</object>
<aside class="notes">
So let's talk about container queries, and how they fit in.

Here’s our pipeline again, with the big loop

Even if we've figured out how to prevent infinite loops, and even if we re-architect browsers to be able to *do* loops – container queries, fundamentally, require taking one or more trips around the loop. Basing styles on styles and layout on layout is literally the whole point.

Every trip around the loop takes time. And if we start using container queries as liberally as we use media queries, today – container-querying all the things or especially nesting container queried components within container-queried components – we might be taking dozens or even hundreds of trips around the loop, each frame.

That's bad for users.

Let's look at an example.
</aside>
</section>

<section>
<img src="images/eqcss.png" alt="EQCSS homepage screenshot" />
<aside class="notes">
The example uses Tommy Hodgin’s EQCSS. Tommy Hodgins has done more work than anyone, anywhere, advocating for Container Queries. He’s built this pollyfill, stuffed it with features, and is amassing a frankly staggering library of demos. I asked him for his worst-performing demo.
</aside>
</section>

<section class="center">
<img src="images/pricing-chart.png" alt="A screenshot of the pricing comparison which performed so badly" style="height: 11em;" />
<p style="margin-top: -0.5em;">40ms best / 150ms worst</p>
<aside class="notes">
And he kindly sent me this pricing comparison chart. Which, when I resize it, well – it's complicated.

First of all, the *visual* performance is more or less ok, but feels just a little bit off, a little weird.

Drilling into the dev tools, we can see why. EQCSS throttles itself, and waits 200ms between executions. This lets a bunch of normal, speedy frames happen in between evaluations.

But every time EQCSS’ resize handler does run, it takes a minumum of 40ms, which means we’re missing a three or four frames. And the worst frames here are blowing the budget by an order of magnitude -- they take 160ms -- we’re missing ten frames in a row. If you drill down and look what’s taking all of that time, Chrome Dev Tools shows you all of these little purple layout boxes with bright red corners, signifying forced reflows that the plugin needed to do as part of its container-querying-work. A lot of those represent small trips around this plugin’s particular implementation of the element-query loop for some subtree of the page. Add them up, and you get 6fps performance, instead of 60.
</aside>
</section>


<section class="center">
<img src="images/shopify.png"  alt="Two screenshots of the Shopify admin page, showing how it responsively adapts" />
<p>Shopify <a href="http://www.creativebloq.com/features/how-to-make-responsive-web-apps-with-container-queries">implemented</a> (and then un-implemented) container queries</p>
<aside class="notes">
And indeed - bad layout performance killed what was, to my knowledge, the first big-deal in-production implementation of container queries, on Shopify's admin pages. [Jonathan Snook, who I think is in the audience today, led the implementation, and has written and spoken about it -- seek those articles out, they were a huge help to me, putting together this talk]. Anyways, shopify built and deployed real-life container queries -- only to, after a year or so, move away from them.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-conversation="none"  data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/_lemonmade">@_lemonmade</a> <a href="https://twitter.com/snookca">@snookca</a> Any insight into why Shopify moved away from JS-based container queries in the admin? FoUC, or?</p>&mdash; Eric Portis (@etportis) <a href="https://twitter.com/etportis/status/870280168413085696">June 1, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">We had problems with forced reflows and layout thrashing, especially on page load. It was probably partially our implementation of them tho.</p>&mdash; Dominic McPhee (@dfmcphee) <a href="https://twitter.com/dfmcphee/status/870458614842105856">June 2, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">But were they ever a joy to use. I miss them.</p>&mdash; Scott Vinkle (@svinkle) <a href="https://twitter.com/svinkle/status/870462425199497216">June 2, 2017</a></blockquote>

<aside class="notes">
I asked why and got this pair of responses, which sums up the promise and peril of container queries nicely.

They were too slow. But boy do we miss them.
</aside>
</section>

<section class="title">
<h1>Paths forward</h1>
<aside class="notes">
So, that’s depressing. Where does that leave us? How do we move forward?

I'm happy to report that some very smart people have some very good ideas and are actively working on pieces of the puzzle.
</aside>
</section>

<section class="center">
<img src="images/containment-fast.jpg" alt="Two summaries of layout performance, showing the enormous speedup enabled by `contain: layout;`." style="height: 5em; margin: 0.5em auto; border-radius: 0.125em;" />
<h1><code class="language-css">contain: strict;</code> <br/> to the <a href="https://developers.google.com/web/updates/2016/06/css-containment">rescue?</a></h1>
<aside class="notes">
The first puzzle piece, we've already mentioned, actually: CSS Containment. I said before that Containment might be the thing that prevents us from creating infinite container query loops – well, it might help offset some of the performance impact of container queries, too. When we prevent children from being able to influence the size, layout, or appearance of their parents – turns out – browsers can usefuly limit and optimize a bunch of layout work. So perhaps, a solution that brought a lot of both container queries **but also** style containment to the web, wouldn't be so bad for performance after all.

I haven’t done a lot of testing here myself, but Paul Lewis published this example when the `contain` property landed in Chrome, showing a re-layout time dropping from 50-something ms all the way down to 0.05ms, all because of this one weird CSS property.

I dunno. Seems promising?
</aside>
</section>

<section>
<h1>Asynchronicity</h1>
<p>Knock. there? Async container queries Who’s knock!</p>
<aside class="notes">
The second idea: make sure that, even if our container querying is slow, we minimize the damage that we’re doing to users’ experiences by doing the work asynchronously.

Browsers respond to Media Queries synchronously. Which is to say, when a media query toggles between true and false, the browser’s entire world stops for as long as it needs to so that it can respond to the change.

If we can't make container queries as performant as media queries, perhaps we can make them a little less world-stopping. We can let the browser re-schedule container query work, or maybe even push it to the next frame, so that we can continue to keep the rest of the user’s experience from feeling "stalled" or "stuck".

I’m happy to report that there’s a working implementation of this idea too, behind a flag in Chrome: 
</aside>
</section>

<section class="center">
<img src="images/resizeobserver.png" style="height: 8em; margin: 0.5em auto;" alt="A screenshot of the ResizeObserver spec" />
<h1>I <span style="color: red; text-shadow: 0.05em 0.05em 0.1em rgba(0,0,0,0.3); margin-right: 0.4ch;">❤</span>️ResizeObserver</h1>
<aside class="notes">
And it's called ResizeObserver.

The more I learn about ResizeObserver, the more I love it. It’s pretty much a purpose-built Container Query toolkit.

First and foremost, it lets you attach resize event listeners directly to elements. The current batch of prolyfills have to listen to a whole bunch of possibly-related events –– like window resizes and DOM changes -- and then check to see if any element resizing actually happened.

ResizeObserver also provides access to a stripped-down set of very-cheap-to-query element geometry. Current prolyfills all have to make extensive use of element.getComputedStyles, which forces a reflow to insure that the queried styles are up-to-date. ResizeObserver gives you access to fresh element geometry far more cheaply.

Next up is what we started with: asynchronusness. The callbacks that you register with ResizeObserver are treated as what browsers call "microtasks." Which means that the browser doesn’t drop everything and run them on the main thread as soon as a resize happens. Instead, they're batched up and run at a precise, later time: just after the next layout and just before the next paint. This ensures that you're not doing any work too early -- you're not going to be surprised by any additional layout changes that you weren't expecting. And you're not going to be doing it too late, either -- as long as it doesn't take too long, you can be sure you'll get that work in before the next paint. Most importantly, batched-up asynchronous callbacks don’t interrupt any other super-important intra-frame work - like, say, responding to user input.

Oh! And! ResizeObserver *also* features a smart way to deal with infinite loops. Because we're in Javascript land, it *can't* keep you from creating infinite layout→response→layout→response→layout→response loops. But it does use a thoughtful strategy – based on nesting-levels - to make sure that it breaks out of those loops in sensible ways, so that the browser can paint, deal with other work that it's doing, and then take one more trip around your infinite loop before the **next** frame.

You've already seen examples of that. This very slide deck, the one right in front of you now, is running a simple, ResizeObserver-based container-query implementation that I slapped together for the purposes of this talk. All of the looping examples that I've shown you flicker between states exactly once per frame, without freezing, stuttering, throwing a call stack exception, or preventing me from interacting with the page, because they were built with ResizeObserver.

In short, ResizeObserver -- perhaps combined with explicit style containment -- might give us everything that we need to implement smart, as-performant-as-possible container queries -- in JavaScript.

Now, wait, I hear you saying... don't we want them in CSS?

Which brings me to the last big idea that the smartest spec and browser folks in the world have about how to make Container Queries a thing. Excitingly, it's where we come in.
</aside>
</section>

<section class="center">
<p class="bigemoji" style="margin-bottom: 0.6em;"><span style="display: block; margin-top: -1em; transform: rotate(180deg) translate(0ch, -0.9em); font-size: 1.2em;">🎩</span>🐇</p>
<h1>✨Houdini✨</h1>

<aside class="notes">
How many of you have heard of Houdini, or the Extensible Web Manifesto?

Ok, well Houdini is a major effort by all sorts of browser and spec folks to give front end developers as much access as possible to the lower-level primitives of CSS. Houdini wants to *explain the magic* of CSS, in Javascript.

The idea here is that, basically, top-down development of web platform features -- where browser vendors and spec authors make all of the big platform-level decisions, and humble front end developers simply receive those decisions and have to live with them -- is bad for everyone. Wouldn't it be better if everyday developers could implement experimental new features *themselves*? This would mean that new features were forged, not in long, hypothetical arguments on mailing lists, by Google, Apple, Mozilla and  Microsoft employees who write more C++ than they do CSS -- but out in the real world, via real useage, on real web pages. And then, eventually, if there’s consensus around good implementaitons of good ideas – they’ll get pulled into the platform and supported natively.

The best example of this sort of model is, I think, JQuery. Which was iterated on for years – became the dominant thing that everybody used everywhere all of the time – and then, finally, had its best ideas adopted by Javascript and the DOM API.

Houdini wants to pave the way for things like JQuery to happen in CSS.

It's a grand idea and a good one. And, brought to fruition, it would mean that we, as a community, could take tools like ResizeObserver and `contain: strict`, use them to build a JavaScript based container queries implementation, and then wrap it up in a nice, tidy, custom CSS syntax. Which would be used it on real web pages and iterated on it in response to observed problems and optimized for real use cases - before being baked into the web platform as a whole.

For a problem as big, and tricky, and in need of careful scoping, as container queries, you can hopefully see the benefits of this path to a solution.

Well, I have some good news and some bad news.

</aside>
</section>


<section class="center">
<img src="images/ishoudinireadyyet.png" style="height: 10em;" alt="Houdini isn't ready yet." />
<h1>No.</h1>
<aside class="notes">
Bad news first.

Here's a handy website with the handy url ishoudinireadyyet.com

As you can see, the answer is more or less, no.

Heck, I didn't mention this earlier, but, while support in other engines will probably come soonish, even ResizeObserver and contain:strict are currently only implemented in Blink. So while we can start to build experimental things in Chrome, you can't really deploy them yet – and you might not be able to for years.

That's some pretty bad news.

</aside>
</section>

<section>
<h1>The Prolyfills are Alright</h1>
<aside class="notes">
But the good news is that a lack of widely-supported low-level tooling hasn't stopped a gaggle of intrepid developers from prolyfilling container-queries anyways. And the resulting  libraries are, I’m here to tell you, suprisingly good! They are - depending on your use case of course - ready for production use.
</aside>
</section>

<section>
<ul class="prolyfill-list">
<li>
<a href="https://github.com/ausi/cq-prolyfill" class="project">cq-prolyfill</a>
<span class="by">by Martin Auswo<span class="diacritic">¨</span>ger</span>
</li><li>
<a href="http://elementqueries.com/" class="project">EQCSS</a> <span id="cssplus">(&amp; <a href="http://csspl.us/" class="project">CSSPlus</a>)</span>
<span class="by">by Tommy Hodgins</span>
</li><li>
<a href="http://elq.io" class="project">ELQ</a>
<span class="by">by Lucas Wiener</span>
</li>
<li>
<a href="http://marcj.github.io/css-element-queries/" class="project">CSS Element Queries</a>
<span class="by">by Marc J Schmidt</span>
</li>
<li>
<a href="https://github.com/Snugug/eq.js" class="project">eq.js</a>
<span class="by">by Sam Richard</span>
</li>
<li>
<a href="https://github.com/ZeeCoder/container-query" class="project">Container Query</a>
<span class="by">by Viktor Hubert</span>
</li><li>
<a href="https://github.com/lemonmade/container-queries" class="project">ContainerQueries</a>
<span class="by">by Chris Sauve<span class="diacritic">´</span></span>
</li><li style="text-align: right;">
...and <a href="https://github.com/search?l=JavaScript&q=container+OR+element+queries&type=Repositories&utf8=%E2%9C%93">many more</a>!
</li>
</ul>
<aside class="notes">
I’ve already mentioned a couple of my favorites.

First, there’s Martin Auswoger’s cq-prolyfill, which implements the smart, infinite-loop-free container queries that we’ve already discussed. It’s biggest selling point, though, is performance — it does some very smart things to minimize the number of layouts that it needs to do, so despite not yet supporting ResizeObservers, in my limited testing – it’s totally, usably, speedy.

Second, there’s Tommy Hodgin’s EQCSS, which is so darned full of features... it doesn't limit you to query widths and heights, you can query all sorts of things, like, say, the number of lines of text within an element, or the number of children that an element has.

I should mention too, that Tommy just released a new set of libraries that he's calling CSSPlus, that allow you to do even more things -- including incorporating arbitrary javascript tests into your CSS selectors. This is super-interesting and super-powerful -- it's more or less a generalized evolution of EQCSS that lets you query, not just elements, but, well, anything. Forget element queries and container queries, these are more like Everything Queries -- check em out.

Then there’s ELQ, which is the product of Lucas Weiner’s  master's thesis in computer science. It features a presumably very clever infinite loop resolver that I don't understand.

eq.js by Sam Richard features yet another infinite loop resolver - they call it "greedy" - basically it looks at all of the states in the infinite loop and picks the biggest one? Kinda crazy, but I guess it works! My favorite thing about it is how it requestAnimatinoFrame to get async behavior, similar to ResizeObserver’s.

Marc J Schmidt owns one of the longest-running and most popular implementations, which he and a small team of people are still developing. It's called CSS Element Queries and my favorite thing about it is, in the absence of proper Houdini access points to CSS, it plays a very neat trick with the CSS attribute selector...

Victor Hubert has a brand new library called Container Query that’s the first to be built on ResizeObserver (and it ships with a ResizeObserver polyfill so that you can actually use it, now)...

I should also mention that the code that Shopify deployed, that I mentioned earlier, is actually open source too, and lives in a library called ContainerQueries...

And if you search github for "container queries" or "element queries" you could while away a few afternoons checking out many other container query solutions.

Each of these prolyfills solves the circularity and performance problems inherent in Container queries in a different way. I’ve found them all to be suprisingly usable, and I think we should be using them!
<script>
	var section = document.currentScript.parentNode;
	
	section.init = ( ( section ) => {
		section.listItems = section.querySelectorAll('.prolyfill-list li');
		section.cssPlus = section.querySelector('#cssplus');
		for ( let li of section.listItems ) {
			if ( li !== section.listItems[ 0 ] ) {
				li.classList.add( 'hidden' );
			}
		} 
	} );
	
	section.events = [
		{
			do: ( section )   => { section.listItems[ 1 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 1 ].classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.cssPlus.classList.remove( 'hidden' ); },
			undo: ( section ) => { section.cssPlus.classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.listItems[ 2 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 2 ].classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.listItems[ 3 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 3 ].classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.listItems[ 4 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 4 ].classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.listItems[ 5 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 5 ].classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.listItems[ 6 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 6 ].classList.add( 'hidden' ); }
		},
		{
			do: ( section )   => { section.listItems[ 7 ].classList.remove( 'hidden' ); },
			undo: ( section ) => { section.listItems[ 7 ].classList.add( 'hidden' ); }
		}
	];
</script>
</section>

<section>
<h1>Fight jank!</h1>
<p>Load container queries libraries in the <code class="language-html" style="font-size: 0.625em;">&lt;head&gt;</code>
<aside class="notes">
One piece of advice, if you do: you may run into some jarring flashes of unstyled content, with these libraries. If you load them like you should be really be loading the rest of your javascript -- that is, after all of your HTML and CSS -- they’re going barge in like an obnoxiously late party guest and then immediately re-arrange all of your furniture.

Thankfully, this problem has a simple solution: load your container query library in the `head`, without async or defer. Doing so will set your first paint back by a bit, but the payoff is worth it: no jarring jank.
</aside>
</section>


<section>
<h1>Why wait? Iterate!</h1>
<aside class="notes">
In any case, I’ll say it again: if you’re convinced that Container Queries are a good thing, and if you want them to become a core part of the web platform, the best thing that you can do, as a front end web developer, is to start using these libraries, today.

Maybe on smaller or personal projects at first. I think you might be suprised, as I was, by how fast and useable they are. And as ResizeObserver and Houdini support rolls out, they’re going to become much, much better.

If you run into problems, file issues.

Tweet about your experiences. Write blog posts.

Help container queries help you.
</aside>
</section>

<section>
<img alt="issue screenshot" />
<p>For extra credit...</p>
<h1><a href="github">document your use cases!</a></h1>
<aside class="notes">
If you really want to make a difference, when these libraries end up working for you, and *especially* when they don't, document your use case in a place where the web platform community can see it. The Responsive Issues Community Group has taken up the mantle of shepherding some kind of eventual Container Query spec into existence, and right now the main focus within the Group is defining use cases and requirements. We’ve put up a spiffy skeleton "Use Cases and Requirements" doc, but at the moment, it only contains one very big and very general use case, which is modular components. If you end up thinking of, or solving, or failing to solve, a use case with Container Queries, comment on this issue, and explain what you're doing, or trying to do – the RICG wants to know.
</aside>
</section>

<section>
<h1>Carpe query.</h1>
<aside class="notes">
I don't know whether any of the libraries that exist today will become as popular as, say, JQuery ever was. I don't want to speculate on when container-query-like features will become a part of real, official CSS. And while I love the lofty ideals of Houdini and bottom-up web platform development, the last thing I want to do is hold container queries hostage until Houdini is ready. The web needed container queries years ago. I'll take them however they come.

So I guess my big takeaway for you all is: they're already here!

If you like the idea of container queries, don’t wait for native support to decsend from the heavens. These prolyfills give YOU a better way to build web PAGES -- right now! And they embody a better way for ALL of us to build the web PLATFORM – together.

So use them! Do it for the platform, and do it for yourself.
</aside>
</section>

<section class="title">
<h1>Thanks!</h1>
<aside class="notes">

</aside>
</section>


</body>
</html>