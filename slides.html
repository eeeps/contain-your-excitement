<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="fonts.css" />
<link rel="stylesheet" href="style.css" />
<script defer src="slideshow.js"></script>
<script defer src="named-element-breakpoints.js"></script>
<link rel="stylesheet" href="prism.css" />
<script defer src="prism.js"></script>
<script defer src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<title>Slides</title>
</head>
<body>

<section id="1" class="title">
	<h1>
		<span>Contain</span>
		<span class="twox" style="display: block; border-top: 1px solid white;">Your Excitement</span>
	</h1>
	<hr style="width: 10em; margin: 0;" />
	<p class="twox center" style="color: var(--light-fg);">
		Eric Portis ‚òÖ SmashingConf NYC ‚òÖ 2017-06-13
	</p>
</section>

<section class="title" id="2">
	<h1>Who am I?</h1>
	<img src="images/_headshot2.jpg" alt="Headshot" id="headshot"
		style="
			border-radius: 100%;
			border: 0.175em solid var( --light-bg );
			box-shadow: var( --box-shadow );
			margin-top: -0.5em;
			margin-left: 5em;
			width: 4em;
			rotate: 5deg;
		"
	/>
	<div class="layer" id="eric-arrow" style="padding-top: 5em; padding-right: 1em;">
		<img src="images/arrow.svg" alt="arrow" style="height: 2em; padding-left: 0.25em;" />
		<p
			class="thin"
			style="
				text-transform: uppercase;
				rotate: -5deg;
				font-size: 1.25em;
				margin-top: -0.05em;
			"
		>
			Eric!
		</p>
	</div>
	<aside class="notes">


The notes go here.

Do carriage returns work?

I wonder.

	</aside>
	<script>
		var section = document.currentScript.parentNode;
		
		section.init = ( ( section ) => {
			section.elementsToReveal = [
				section.querySelector( '#headshot' ),
				section.querySelector( '#eric-arrow' )
			]
			for ( element of section.elementsToReveal ) {
				element.classList.add( 'hidden' );
			}
		} );
		
		section.events = [
			{
				do: ( section ) => {
					for ( element of section.elementsToReveal ) {
						element.classList.remove( 'hidden' );
					}
				},
				undo: ( section ) => {
					for ( element of section.elementsToReveal ) {
						element.classList.add( 'hidden' );
					}
				}
			}
		];
	</script>
</section>

<section class="whatido" style="align-content: stretch;">
<style>
.whatido ul {
	list-style: none;
	display: flex;
	flex-direction: column;
	justify-content: space-around;
	height: 100%;
	padding-bottom: 10vh;
	padding-top: 10vh;
}
.whatido .what {
	font-family: SooperSerifThinCondensed2x;
	text-transform: uppercase;
	font-size: 1.5em;
	display: block;
}
.whatido .where {
	color: var(--light-fg);
	font-size: 0.75em;
	display: block;
}
</style>
<ul>
<li><span class="what">Developer Advocate</span> <span class="where">@ Cloudinary</span></li>
<li><span class="what">Hanger-on</span> <span class="where">@ Responsive Issues Community Group</li>
<li><span class="what">Lapsed printmaker-photographer</span> <span class="where">@ Remote Island in Puget Sound</li>
</ul>
<aside class="notes">
Developer Evangelist at Cloudinary, which is an image back-end for web and mobile developers. We help you manage image upload, storage, manipulation, and delivery. If you work with images, especially responsive images, like the ones I‚Äôll be talking about tonight ‚Äî Cloudinary can help you do that work better.

Before I worked at cloudinary, I managed the web store of a tiny fine art print shop in Denver Colorado‚Ä¶ and got *really* upset with the way images worked within responsive layouts‚Ä¶ yadda yadda yadda, I was spending hours in WHATWG mailing lists and writing a weekly newsletter for the responsie images community group, which spec‚Äôd and implemented the features I‚Äôm going to be talkign about today

I still like art, and I live on an island now where I kind of wander around and take weird infared photographs of kelp and things‚Ä¶
the island is called orcas island ; if any of you are ever out in the san juans ; it‚Äôs beautiful and you should all come visit

but enough about me
</aside>
</section>

<section id="2" class="title">
	<h1>Element queries!</h1>
	<div class="layer">
		<p class="sticker" style="
			position: relative;
			left: -3.33rem;
			top: -0.125em;
			margin-top: -2px;
			font-size: 1.33em;
		">
			Container?
		</p>
	</div>
	<aside class="notes">
Let‚Äôs talk about element queries!

[click]

Or container queries, or whatever.
I suppose a brief note on terminology is in order
	</aside>
	<script>
		var section = document.currentScript.parentNode;

		section.init = ( ( section ) => {
			section.stickerLayer = section.querySelector( '.layer' );
			section.stickerLayer.classList.add('hidden');
		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.stickerLayer.classList.remove('hidden');
				},
				undo: ( section ) => {
					section.stickerLayer.classList.add('hidden');
				}
			}
		];
	</script>
</section>

<section class="center">
<p style="font-size: 1.5em;">‚ÄúElement?‚Äù ‚ÄúContainer?‚Äù</p>
<h1 style="margin-top: 0.25em;">Same-same.</h1>
<aside class="notes">
We‚Äôll get into the distinction between ‚Äúelement‚Äù and ‚Äúcontainer‚Äù queries a bit later, but for the first part of this talk, I and some folks that I‚Äôll be quoting will use the terms more or less interchangably.
</aside>
</section>


<section class="center">
<p>Whatever you call them, they‚Äôre</p>
<h1 style="margin-top: 0.25em;">media queries for elements</h1>
<aside class="notes">
And I‚Äôll be using the terms to refer to an idea. In a nutshell: we should be able to adapt element‚Äôs styles based on their own state. Not just the state of the entire viewport.
</aside>
</section>


<section id="2">
	<h1>Media queries are a whole-viewport-solution...</h1>
	<p>...designed to solve whole-document problems.</p>
	<aside class="notes">
It‚Äôs worth taking a moment to think about about where Media Queries came from.

How many of are old enough to have written a print-specific stylesheet?
	</aside>
</section>


<section id="3" class="code">

<div style="height: 4rem;">
	<pre class="before"><code class="language-html">
	&lt;link rel="stylesheet" type="text/css" 
		media="print" href="serif.css"&gt;
	&lt;link rel="stylesheet" type="text/css" 
		media="screen" href="sans-serif.css"&gt;
	</code></pre>

	<pre class="after"><code class="language-css">
	@media print {
		* { font-family: serif }
	}
	@media screen {
		* { font-family: sans-serif }
	}
	</code></pre>

	<pre class="afterafter"><code class="language-css">
	@media screen and (min-width: 400px) {
		...
	}
	</code></pre>
</div>

<footer><p>Example from <a href="https://www.w3.org/TR/2001/WD-css3-mediaqueries-20010404/">the original Media Queries specification</a>, published in 2001.</p></footer>

<aside class="notes">
Well the original media queries spec, piblished sixteen years ago, opens with the following example. This is something that I‚Äôm just barely old enough to remember. But ten or twenty years ago, it was not unheard of for webmasters to provide one style sheet for screens, and a completely different stylesheet for print, containing page styles tailored for 8.5x11, high-resolution, black-and-white, laser-printed pieces of good-old-fashioned paper.

The media queries spec says, hey, this is a decently common use case -- how about we let you wrap these two sets of styles up into the same stylesheet, like this [click]. Media queries let you wrap your media-specific styles in a little @media block -- no separate stylesheet required.

As luck would have it, the spec authors also decided that, as long as they were letting you query media *types*, why not also let you query specific media *features*, say, width? [click]

And just like that, the media queries we all know and love -- along with so much of what we now call "responsive design" -- was born.
</aside>

	<script>
		var section = document.currentScript.parentNode;

		section.init = ( ( section ) => {
			section.before = section.querySelector( '.before' );
			section.after = section.querySelector( '.after' );
			section.afterafter = section.querySelector( '.afterafter' );
			section.after.style.display = 'none';
			section.afterafter.style.display = 'none';
		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.after.style.display = 'block';
					section.before.style.display = 'none';
				},
				undo: ( section ) => {
					section.after.style.display = 'none';
					section.before.style.display = 'block';
				}
			},
			{
				do: ( section ) => {
					section.after.style.display = 'none';
					section.afterafter.style.display = 'block';
				},
				undo: ( section ) => {
					section.after.style.display = 'block';
					section.afterafter.style.display = 'none';
				}
			}
		];
	</script>

</section>

<section class="center">

<!--TODO-->
<img alt="scaling page with big word that changes from small to big" />
<!--change to-->
<img alt="scaling page full of individual components that all have their own small/big changes at different points" />
<h1><del>Responsive pages</del><ins>Modular components</ins></h1>

<aside class="notes">
And, when we we‚Äôre designing web pages, and we want to adapt those pages in response to facts about the whole viewport, they‚Äôre a great solution.

But increasingly, we‚Äôre not really designing monolithic *pages*. We‚Äôre designing modular *components*. And what we want, is the ability to set breakpoints directly on those components.

Whether you‚Äôre working with Web Components, React components, <a href="http://atomicdesign.bradfrost.com/chapter-2/">Brad‚Äôs Atomic Design elements</a>, <a href="https://smacss.com/book/type-module">SMACSS modules</a> or Object-OrientedCSS objects or BEM blocks, <a href="http://styleguides.io/">style-guides and pattern libraries</a>, or even just <a href="https://adactio.com/journal/4523">the high-level notion that we should be designing from our content, out, rather than the page‚Äôs frame, in</a> ‚Äì¬†media queries are a kludge and, in the words of Ian Storm Taylor, <a href="https://ianstormtaylor.com/media-queries-are-a-hack/">a hack</a>.

</aside>
</section>


<section id="eq-example" class="code">
<div class="example-container">
	<div class="resizable example-viewport" id="example_1495648141">
		<style>
			#example_1495648141 .container {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(1px, 1fr));
				grid-gap: var(--margin);
				margin: var(--margin);
			}
			#example_1495648141 .block {
				--named-breakpoints: 2.25em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				background-color: lightblue;

			}
			#example_1495648141 .block.make-it-pink {
				background-color: deeppink;
			}

		</style>
		<div class="container">
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
		</div>
	</div>
</div>
<pre style="margin-bottom: -1.25em;"><code class="language-css">
.block {
	background-color: lightblue; 
}
</code></pre>
<pre class="mediaquery" style="height: 8em;"><code class="language-css">
@media (min-width: 797px) {
	.block {
		background-color: deeppink;
	}
}
</code></pre>
<pre class="elementquery" style="height: 8em;"><code class="language-css">
.block:min-width(100px) {
	background-color: deeppink;
}
</code></pre>
	<script>
	var section = document.currentScript.parentNode;

	section.init = ( ( section ) => {
		section.mediaquery = section.querySelector( '.mediaquery' );
		section.elementquery = section.querySelector( '.elementquery' );
		section.mediaquery.classList.add( 'hidden' );
		section.elementquery.classList.add( 'none' );
		section.container = section.querySelector( '.container' );
		section.lastDiv = section.container.querySelector('.block:last-child');
	} );
	
	section.events = [
		{ // show the media query
			do: ( section ) => {
				section.mediaquery.classList.remove( 'hidden' );
			},
			undo: ( section ) => {
				section.mediaquery.classList.add( 'hidden' );
			}
		},
		{ // increase the margin
			do: ( section ) => {
				section.container.style.margin = 'var(--margin) calc( var(--margin) / 4 )';
				section.container.style.gridGap = 'calc( var(--margin) / 4 )';
			},
			undo: ( section ) => {
				section.container.style.margin = 'var(--margin)';	
				section.container.style.gridGap = 'var(--margin)';
			}
		},
		{
			do: ( section ) => {
				section.container.removeChild(section.lastDiv);
			},
			undo: ( section ) => {
				section.container.appendChild(section.lastDiv);
			}
		},
		{
			do: ( section ) => {
				section.mediaquery.innerHTML = 
				 section.mediaquery.innerHTML.replace('797px', '582px');
			},
			undo: ( section ) => {
				section.mediaquery.innerHTML = 
				 section.mediaquery.innerHTML.replace('582px', '797px');
			}
		},
		{
			do: ( section ) => {
				section.mediaquery.classList.add('none');
				section.elementquery.classList.remove('none');
			},
			undo: ( section ) => {
				section.mediaquery.classList.remove('none');
				section.elementquery.classList.add('none');
			}
		}		
	];
	</script>
	<aside class="notes">
An example‚Äôs in order. Let‚Äôs say I've got a line of five little light-blue flexible components, like this.

And let‚Äôs say that when these boxes get to be 100px wide, I want to change them in some way ‚Äì lets say I want to make them pink.

So, I'll write a media query. I'll figure out how wide the entire viewport is, just as each element hits 100px-wide. And use that whole viewport width as my min-width, like this [click]

Now what I‚Äôve done here, that‚Äôs kludgy and bad, is bake a bunch of external state into what should just be a statement about the boxes. Remember, all I care about is the width the boxes. If they‚Äôre at least 100px wide, make them pink. But now I'm in a situation where, if many things *around* the boxes change -- let's say I tweak my margins [click], or change the number of boxes [click] -- The media query no longer does what I want, and I‚Äôll have to change it. [click] That's bad!

What I really want to be able to say, here, is say exactly what I mean. When these specific *elements* are at least 100px wide, turn them pink. Like this [click].

That's an element query.
	</aside>
</section>

<!--
<section>
<h1 class="center">Pretty neat!</h1>
<p>Now show me something useful?</p>
</section>


<section id="5">
<h1>Other use cases</h1>
<ul>
	<li>interactive content</li>
	<li>modular components!</li>
	<li>any kind of content-out (rather than viewport-in) design</li>
</ul>
<aside class="notes">
Interactive content
Best example, this slide deck right here?
toolbars that fly out, resize in response to user input

Modular components
React... Atomic design, pattern libraries
legos

Content-out design
Even if you‚Äôre designing static pages full of one-off design work, even if you don't care about modular reusable components at all
Any time you're design from the content, out, rather than from page dimension and a given set of breakpoints, in -- you want element queries.
- point back to weather widgets
- mobile first, stretch it till it breaks, set a break point
- dont want to have to re-write those breakpoints later, because some other part of the page changed
</aside>
</section>
-->


<section id="tweets" class="title">
<h1>People have been asking</h1>
<p>for element queries</p>
<aside class="notes">
And hoo boy, have people been asking for them.
</aside>
</section>

<section class="center">
<figure>
<img src="images/ResponsiveContainersScrenshot.png" alt="A screenshot of http://blog.andyhume.net/responsive-containers/"  style="max-height: 65vh;" />
<figcaption>
<p><cite><a href="http://blog.andyhume.net/responsive-containers/">Responsive Containers</a></cite> by Andy Hume</p>
</figcaption>
</figure>
<aside class="notes">
Here‚Äôs the first mention I that could find of the general concept ‚Äì¬†an clear, concise, and six-year-old blog post from Andy Hume, complete with a working, javascript-based implementation and demo of the idea. Andy called them ‚ÄúSelector Queries‚Äù. 
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">We need native CSS media queries at the element/component/widget level, not just the viewport. Make it so, internetz.</p>&mdash; Nicolas (@necolas) <a href="https://twitter.com/necolas/status/299573744307941376">February 7, 2013</a></blockquote>
<aside class="notes">
Turns out, they were a good idea...
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Great read about the #1 missing tool for responsive design: Element queries  <a href="http://t.co/EARts4HWWr">http://t.co/EARts4HWWr</a> (viewport queries are still valuable)</p>&mdash; Brad Frost üá∫üá∏ (@brad_frost) <a href="https://twitter.com/brad_frost/status/319929504422322176">April 4, 2013</a></blockquote>
<aside class="notes">
...it wasn‚Äôt too long before some of the smartest minds in the industry were calling element-level queries ‚Äúthe number one missing tool for responsive design.‚Äù
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Ahh, Spring‚Äîwhen a young man‚Äôs fancy turns to thoughts of element queries, what that syntax might look like, and how one might prototype it.</p>&mdash; Mat Marquis (@wilto) <a href="https://twitter.com/wilto/status/466673241130430464">May 14, 2014</a></blockquote>
<aside class="notes">
By 2014, serious efforts were underway to turn what had been just an exciting idea into an empowering reality.

But. There were problems. More on those later.

For now, I just want to take you on a journey of increasingly sad and desparate tweets.
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Monthly tweet about how _super_ helpful natively supported element queries would be.</p>&mdash; Tim Kadlec (@tkadlec) <a href="https://twitter.com/tkadlec/status/493849870554259457">July 28, 2014</a></blockquote>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Why element queries?<br><br>Less CSS to write, more modular &amp; maintainable CSS/HTML, smarter responsive images, web components, etc.</p>&mdash; Tim Kadlec (@tkadlec) <a href="https://twitter.com/tkadlec/status/493852410700247041">July 28, 2014</a></blockquote>
<aside class="notes">
It starts innocently enough, with earnest pleas and sound arguments.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Coulda used ElementQueries about 45 times today.</p>&mdash; Dave Rupert (@davatron5000) <a href="https://twitter.com/davatron5000/status/558402932509401088">January 22, 2015</a></blockquote>
<aside class="notes">
But by 2015, impatience started to set in.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Does anyone know what the current state of <a href="https://twitter.com/hashtag/CSS?src=hash">#CSS</a> Element Queries is? Any updates on whether cyclic dependency can be solved/worked around?</p>&mdash; Sara Soueidan üê¶ (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/594947884090429440">May 3, 2015</a></blockquote>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">If I had to choose only one new CSS feature to be implemented asap, it would be container queries. So much NEED. <a href="https://twitter.com/hashtag/respond16?src=hash">#respond16</a></p>&mdash; Sara Soueidan üê¶ (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/718308762033987584">April 8, 2016</a></blockquote>

<aside class="notes">
Front end developers began do wonder... is anyone listening?
</aside>
</section>

<section>
<!--<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Serious question: where are element queries at? Any updates since the last ‚Äúthey cause a loop so we have to figure out how to do this‚Äù one?</p>&mdash; Sara Soueidan üê¶ (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/807982469714706434">December 11, 2016</a></blockquote>-->

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">All I want in 2017 on the Web is Container Queries. Seriously.</p>&mdash; Sara Soueidan üê¶ (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/812333338744721408">December 23, 2016</a></blockquote>
<aside class="notes">
How many times do we have to say it?
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">hypothesis<br><br>If element queries were real, over 50% of the media queries we write would be element queries.</p>&mdash; Chris Coyier (@chriscoyier) <a href="https://twitter.com/chriscoyier/status/668796363900100613">November 23, 2015</a></blockquote>
<aside class="notes">
Doesn‚Äôt anybody understand what a big deal element queries would be?
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I wonder when and if we‚Äôll ever get Container Queries in CSS. It‚Äôs only possibly the most useful RWD technique. The wait is depressing.</p>&mdash; Sara Soueidan üê¶ (@SaraSoueidan) <a href="https://twitter.com/SaraSoueidan/status/744117584941875200">June 18, 2016</a></blockquote>
<aside class="notes">
Evidently, they don't. Diffrent developers have responded to this differently. Sadness is a common reaction.
</aside>
</section>

<!--
<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">That time of day when you run into a CSS layout that‚Äôs going to be a total hack job to build without element/container queries.</p>&mdash; Scott Jehl (@scottjehl) <a href="https://twitter.com/scottjehl/status/723575660065726465">April 22, 2016</a></blockquote>
<aside class="notes">
A certain fatalism began to creep into the conversation.
</aside>
</section>
-->

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">are container queries here yet<br><br>dot tumblr dot corn</p>&mdash; Ethan Marcotte (@beep) <a href="https://twitter.com/beep/status/723156713373732865">April 21, 2016</a></blockquote>
<aside class="notes">
Others have resorted to dry humor.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">FUTURE BROWSER v154.2 release notes<br>* JS engine optimizations‚Äîtechnically now a time machine<br>* nothing on container queries yet‚Äîstop asking</p>&mdash; Zach Leatherman (@zachleat) <a href="https://twitter.com/zachleat/status/748241672757084160">June 29, 2016</a></blockquote>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">The fact that we‚Äôll probably get stable, cross browser WebVR before container queries is a good example of what‚Äôs wrong with our industry.</p>&mdash; Zach Leatherman (@zachleat) <a href="https://twitter.com/zachleat/status/790926735156011008">October 25, 2016</a></blockquote>
<aside class="notes">
Bitterness (you know, sometimes the saddest tweets are the truest tweets...)
</aside>
</section>


<section>
<div  style="zoom: 0.75;">
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Well, I tried. <a href="https://t.co/mCfx2Tor0O">pic.twitter.com/mCfx2Tor0O</a></p>&mdash; Zach Leatherman (@zachleat) <a href="https://twitter.com/zachleat/status/743219273275826176">June 15, 2016</a></blockquote>
</div>
<aside class="notes">
And desperate cries for help
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="und" dir="ltr">I want my <br>element <br>element<br>element<br>I want my element<br>element<br>element<br>element<br>Chilis element queries, Chilis element queries<br>barbecue sauce</p>&mdash; Brad Frost üá∫üá∏ (@brad_frost) <a href="https://twitter.com/brad_frost/status/765926034604695552">August 17, 2016</a></blockquote>
<aside class="notes">
Some, sadly, have been driven to madness.
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Be our witness? <a href="https://twitter.com/chriscoyier">@chriscoyier</a> and I just bet $20 that element queries would get implemented. I said no, he said yes. :)</p>&mdash; Nicole Sullivan (@stubbornella) <a href="https://twitter.com/stubbornella/status/611925043950538753">June 19, 2015</a></blockquote></script>
<aside class="notes">
My favorite response might be Nicole Sullivan's. Nicole thought, well, if I can't have element queries, at least I can have $20!
</aside>
</section>

<section>
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/grigs">@grigs</a> DO CONTAINER QUERIES NEXT <a href="https://t.co/fVT8NXGnqQ">pic.twitter.com/fVT8NXGnqQ</a></p>&mdash; Ethan Marcotte (@beep) <a href="https://twitter.com/beep/status/862791570826960896">May 11, 2017</a></blockquote>
<aside class="notes">
For those who, in 2017, still nurture hope, the message is loud and clear
</aside>
</section>

<section id="notyet" class="title">
<h1>What‚Äôs the hold up?</h1>
<aside class="notes">
</aside>
</section>

<section>
<p>Please excuse a wildly simplified explanation of</p>
<h1>How Browsers Work</h1>
<aside class="notes">
</aside>
</section>

<section id="how-browsers-work">
	<object type="image/svg+xml" data="images/how-browsers-work.svg" style="grid-column: 1 / 4; width: 100vw; height: 100vh;" onload="
		let s = this.parentElement;
		s.svg = this.getSVGDocument();
		s.html = s.svg.getElementById('HTML'),
		s.css = s.svg.getElementById('CSS'),
		[
			s.dom = s.svg.getElementById('DOM'),
			s.cssom = s.svg.getElementById('CSSOM'),
			s.renderTree = s.svg.getElementById('Render-Tree'),
			s.boxTree = s.svg.getElementById('Box-Tree'),
			s.pixelsOnScreen = s.svg.getElementById('Pixels-on-screen'),
			// s.loadAndParse = s.svg.getElementById('Load-and-Parse'),
			s.loadAndParseTopArrow = s.svg.getElementById('Load-and-Parse-top-arrow'),
			s.loadAndParseBottomArrow = s.svg.getElementById('Load-and-Parse-bottom-arrow'),
			s.loadAndParseText = s.svg.getElementById('Load-and-Parse-text'),
			s.runSelectors = s.svg.getElementById('Run-Selectors'),
			s.layout = s.svg.getElementById('Layout'),
			s.paint = s.svg.getElementById('Paint'),
			s.elementQueries = s.svg.getElementById('ELEMENT-QUERIES')
		].forEach( ( element ) => {
			element.classList.add('none');
		} );
	">
	 A big ol' diagram
	</object>
	<aside class="notes">
	</aside>
	<script>
		var section = document.currentScript.parentNode;
		
// 		section.init = ( ( section ) => {
// 			section.object = section.querySelector('object');
// 			section.svg.addEventListener( 'load', () => {
// 				section.svg = section.querySelector('object').getSVGDocument();
// 			} );
// 			// section.html = section.svg.getElementById('HTML');
// 			// section.html.setAttribute('visibility', 'hidden');
// 		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.loadAndParseText.classList.remove('none');
				},
				undo: ( section ) => {
					section.loadAndParseText.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.loadAndParseTopArrow.classList.remove('none');
				},
				undo: ( section ) => {
					section.loadAndParseTopArrow.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.dom.classList.remove('none');
				},
				undo: ( section ) => {
					section.dom.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.loadAndParseBottomArrow.classList.remove('none');
				},
				undo: ( section ) => {
					section.loadAndParseBottomArrow.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.cssom.classList.remove('none');
				},
				undo: ( section ) => {
					section.cssom.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.runSelectors.classList.remove('none');
				},
				undo: ( section ) => {
					section.runSelectors.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.renderTree.classList.remove('none');
				},
				undo: ( section ) => {
					section.renderTree.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.layout.classList.remove('none');
				},
				undo: ( section ) => {
					section.layout.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.boxTree.classList.remove('none');
				},
				undo: ( section ) => {
					section.boxTree.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.paint.classList.remove('none');
				},
				undo: ( section ) => {
					section.paint.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.pixelsOnScreen.classList.remove('none');
				},
				undo: ( section ) => {
					section.pixelsOnScreen.classList.add('none');
				}
			},
			{
				do: ( section ) => {
					section.elementQueries.classList.remove('none');
				},
				undo: ( section ) => {
					section.elementQueries.classList.add('none');
				}
			}
		];
	</script>
</section>



<section>
	<p class="bigemoji center">üîÅ</p>
	<p>Problem #1:</p>
	<h1>Circularity</h1>
</section>

<section class="code" id="circular-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496355733">
		<style>
			#example_1496355733 .block {
				margin: var(--margin);
				--named-breakpoints: 10em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				width: calc( 100% - var(--margin) * 2 );
				background-color: lightblue;
			}
			#example_1496355733 .block.make-it-pink {
				width: 5em;
			}

		</style>
		<div class="block"></div>
	</div>
</div>
<pre><code class="language-css">
.block:min-width(10em) {
	width: 5em;
}
</pre></code>
</section>

<section class="code" id="one-way-adaptation-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496382980">
		<style>
			#example_1496382980 .container {
				margin: 0 calc(var(--margin) / 2);
				display: flex;
			}
			#example_1496382980 .block {
				margin: var(--margin) calc(var(--margin) / 2);
				--named-breakpoints: 3em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				width: calc( 100% - var(--margin) * 2 );
				background-color: lightblue;
			}
			#example_1496382980 .block.make-it-pink {
				border: 0.25em solid deeppink;
			}

		</style>
		<div class="container">
			<div class="block"></div>
			<div class="block"></div>
			<div class="block"></div>
		</div>
	</div>
</div>
<pre><code class="language-css">
.container {
	display: flex;
}

.block:min-width(3em) {
	border: 0.25em solid deeppink;
}
</pre></code>
</section>



<section class="code" id="one-way-adaptation-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496381020"
	     style="width: 7.87em;">
		<style>
			#example_1496381020 .container {
				margin: 0 calc(var(--margin) / 2);
				display: flex;
			}
			#example_1496381020 .block {
				margin: var(--margin) calc(var(--margin) / 2);
				--named-breakpoints: 3.25em make-it-pink;
				height: calc( var(--height) - var(--margin) * 2 );
				width: calc( 100% - var(--margin) * 2 );
				background-color: lightblue;
				padding: 0.125em;
				font-family: 'SooperSerifThinCondensed';
				font-size: 0.75em;
			}
			#example_1496381020 .block.make-it-pink {
				letter-spacing: 0.1em;
			}

		</style>
		<div class="container">
			<div class="block">Super</div>
			<div class="block">califragilistic</div>
			<div class="block">expiali</div>
			<div class="block">docious</div>
		</div>
	</div>
</div>
<pre><code class="language-css">
.container {
	display: flex;
}

.block:min-width(3.25em) {
	letter-spacing: 0.1em;
}
</pre></code>
</section>

<section class="center">
	<h1>Element Queries</h1>
	<div class="layer">
		<p class="sticker" style="
			position: relative;
			left: -2.5rem;
			top: -0.125em;
			margin-top: -2px;
			background-color: var(--dark-bg);
		">
			Container!
		</p>
	</div>
	<script>
		var section = document.currentScript.parentNode;
		
		section.init = ( ( section ) => {
			section.stickerLayer = section.querySelector( '.layer' );
			section.stickerLayer.classList.add('hidden');
		} );
		
		section.events = [
			{
				do: ( section ) => {
					section.stickerLayer.classList.remove('hidden');
				},
				undo: ( section ) => {
					section.stickerLayer.classList.add('hidden');
				}
			}
		];
	</script>
</section>


<section class="code" id="circular-container-example">

<div class="example-container">
	<div class="resizable example-viewport" id="example_1496356616">
		<style>
			#example_1496356616 .wrapper {
				--named-breakpoints: 10em make-it-pink;
				margin: var(--margin);
				border: 0.0625em solid deeppink;
			}
			#example_1496356616 .block {
				height: calc( var(--height) - var(--margin) * 2 - 0.125em );
				background-color: lightblue;
			}
			#example_1496356616 .wrapper.make-it-pink > .block {
				width: 5em !important;
			}

		</style>
		<div class="wrapper">
			<div class="block"></div>
		</div>
	</div>
</div>
<pre><code class="language-css">
.wrapper {
	border: 0.0625em solid deeppink;
}

.block:container(width > 10em) {
	width: 5em;
}
</code></pre>

<div class="poo layer">
<img style="width:7.5em;" src="images/pile-of-poo.png" alt />
</div>

<script>
	var section = document.currentScript.parentNode;

	section.init = ( ( section ) => {
		section.codeEl = section.querySelector("code.language-css");
		section.wrapper = section.querySelector(".wrapper");
		section.block = section.querySelector(".block");
		section.poo = section.querySelector(".poo");
		section.poo.classList.add('hidden');
		section.codeElContents = [
			section.codeEl.textContent,
			".wrapper {\n\
	border: 0.0625em solid deeppink;\n\
	float: left;\n\
}\n\
\n\
.block:container(width > 10em) {\n\
	width: 5em;\n\
}",
			".wrapper {\n\
	border: 0.0625em solid deeppink;\n\
	float: left;\n\
}\n\
\n\
.block {\n\
	width: 11em;\n\
}\n\
\n\
.block:container(width > 10em) {\n\
	width: 5em;\n\
}"
		];
	} );
	
	section.events = [
		{
			do: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 1 ], Prism.languages.css);
				section.wrapper.style.float = 'left';
				
			},
			undo: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 0 ], Prism.languages.css);
				section.wrapper.style.float = 'none';
			}
		},
		{
			do: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 2 ], Prism.languages.css);
				section.block.style.width = "11em";
			},
			undo: ( section ) => {
				section.codeEl.innerHTML = Prism.highlight(section.codeElContents[ 1 ], Prism.languages.css);
				section.block.style.width = "100%";
			}
		},
		{
			do: ( section ) => {
				section.poo.classList.remove( 'hidden' );
			},
			undo: ( section ) => {
				section.poo.classList.add( 'hidden' );
			}
		}
	];
</script>

</section>

<section>
<h1>Two solutions...</h1>
</section>

<section>
<h1><span style="font-family: SooperSerifThinCondensed2x;">(closest)</span> Container <span style="font-family: SooperSerifThinCondensed2x;">(whose width is not influenced by its children)</span> Queries</h1>
</section>

<section>
<img src="images/cq-prolyfill.png" alt="screenshot of Martin Auswoger‚Äôs blog post about container query solutions" style="height: 60vh; margin: -0.5em auto 0.5em auto;" />
<p>Conceived of + implemented by Martin Auswoger</p>
<footer>
<p><a href="https://github.com/ausi/cq-prolyfill">https://github.com/ausi/cq-prolyfill</a> + <a href="https://au.si/css-container-element-queries">https://au.si/css-container-element-queries</a></p></footer>
</section>

<section>
<img src="images/css-containment.png" style="height: 60vh;" alt="screenshot of the CSS Containment Module Level 1 draft" />
<h1><code class="language-css" style="font-size: 1rem; box-shadow: var(--box-shadow);">contain: strict;</code></h1>
<footer><p><a href="https://drafts.csswg.org/css-contain/">https://drafts.csswg.org/css-contain/</a></p></footer>
</section>

<section>
	<p class="bigemoji center">üèö</p>
	<p>Problem #2:</p>
	<h1>Breaks layout engine architecture</h1>
	<aside class="notes">
	Remember our diagram from earlier? For twenty years, browsers have been following that path from left, to right, in a single pass.
	
	Even if we can solve the problem of infinite loops -- a giant backwards arrow and, finite trips around the loop are still problematic. Especially when browsers assume and have always assumed that we can figure out which styles apply to what elements BEFORE we know how large those elements are.
	</aside>
</section>



<section>

<div style="zoom: 0.8;" />
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Currently selectors are run and styles computed independently, and before, layout. They&#39;re separate layers.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818560290224619520">January 9, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Layout engine architecture is currently designed around this split.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818561591427801088">January 9, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Changing that would require major high level architectural work in all engines.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818561896961802240">January 9, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">Which isn&#39;t impossible, but certainly isn&#39;t going to be easy.</p>&mdash; fantasai (@fantasai) <a href="https://twitter.com/fantasai/status/818562265574084608">January 9, 2017</a></blockquote>
</div>

<aside class="notes">
Nicely summarized by Erika ETODO, aka fantasai, of CSS Working Group fame, in response to a question asked by none other than Sarah, about what it would take for Container queries to become a thing.


</aside>
</section>

<section>
<blockquote class="mailing-list">
<pre>
<span class="meta">On Thu, 21 Mar 2013 at 3:08 PM, <a href="https://lists.w3.org/Archives/Public/www-style/2013Mar/0403.html">Elliott Sprehn wrote</a>:</span>

<span class="meta">&gt;</span> This doesn't seem very easy to implement because <em>it breaks the sequential</em>
<span class="meta">&gt;</span> <em>processing model</em>:
<span class="meta">&gt;</span> 
<span class="meta">&gt;</span> 1. resolve style on elements such that you have a flattened set of
<span class="meta">&gt;</span> properties.
<span class="meta">&gt;</span> 2. layout the elements if things are different then the last time we did
<span class="meta">&gt;</span> step 1.

<span class="meta">&gt;</span> <em>This would be a big undertaking in Webkit so I don't think it falls</em>
<span class="meta">&gt;</span> <em>anywhere in the near future.</em>


<span class="meta">On Thu, Mar 21, 2013 at 6:34 PM, <a href="https://lists.w3.org/Archives/Public/www-style/2013Mar/0421.html">Elliott Sprehn wrote</a>:</span>

<span class="meta">&gt;</span> I think there's a high implementation cost for this kind of thing

<span class="meta">&gt;</span> <em>It certainly could be done given enough time and someone very</em>
<span class="meta">&gt;</span> <em>motivated...</em>
</pre>
</blockquote>

<aside class="notes">
And here‚Äôs Elliott Sprehn, WebKit implementor, saying the same thing on the www-style mailing list.

Container queries would be an unusually large amount of work, for implementors.

As we‚Äôve seen, they‚Äôre‚Äôs also been an extraordinary amount of demand for them, from authors.

So we‚Äôve got an unstoppable force, which is authors working with components in responsive designs, yearning for container queries ‚Äî meeting an immovable object, which is 20 years of tightly-optimized code in browsers, whose fundamental architectural assumptions, container queries would break.

What happens when those things collide?
</aside>
</section>

<section>
	<blockquote>
	<img src="images/priority-of-constituencies.png" alt="Section 3.2 of the HTML design principles, which reads, ‚ÄúIn case of conflict, consider users over authors over implementors over specifiers over theoretical purity.‚Äù" />
	<footer>‚Äî<cite><a href="https://www.w3.org/TR/html-design-principles/#priority-of-constituencies">HTML Design Principles</a></cite></footer>
	</blockquote>
	<aside class="notes">
	Luckily, we have this passage the HTML design principles to guide us through it. The priority of constituencies, which states that...
	
	This is a beautiful statement, which, at multiple levels, implores the powerful few to understand and serve the relative many, who must live with the products and consequences of their work.

	Also, it means, we win, right!? Authors over implementors! That means if we 
	want container queries, but implementors think they‚Äôre really hard or whatever ‚Äì too bad!¬†quit your bitchin‚Äô and start re-architectin‚Äô!
	
	But. In this hierarchy. There is one constituency whose concerns can, and should, matter more than ours. [click] Users. Which brings us to the last, biggest, and best reason that Container Queries aren‚Äôt a thing yet.
	</aside>
	<script>
	var section = document.currentScript.parentNode;

	section.init = ( ( section ) => { 
		section.screenshot = section.querySelector('img');
		section.srcs = [
			section.screenshot.src,
			'images/authors-over-implementors.png',
			'images/users-over-authors.png'
		];
	} );
	
	section.events = [
		{
			do: ( section ) => {
				section.screenshot.src = section.srcs[1];
			},
			undo: ( section ) => {
				section.screenshot.src = section.srcs[0];
			}
		},
		{
			do: ( section ) => {
				section.screenshot.src = section.srcs[2];
			},
			undo: ( section ) => {
				section.screenshot.src = section.srcs[1];
			}
		}
	];
	</script>
</section>


<section>
	<p class="bigemoji center">üêå</p>
	<p>Problem #3:</p>
	<h1>Fundamentally slow</h1>
	<aside class="notes">

	</aside>
</section>

<section>
	<p class="bigemoji center">üêá</p>
	<p>...and it needs to be FAST</p>
	<aside class="notes">
First load paint isn't actually all that important, relative to everything coming over the network.

But after that, during resizes, animations, or user interactions ‚Äì¬†paint happens at the refresh rate of the display -- usually 60 times per second.
	</aside>
</section>

<section>
<h1 style="text-align: center; "><span style="font-size: 10rem; display: block; margin-bottom: -1.75rem;">16</span> milliseconds</h1>
<aside class="notes">
So that‚Äôs 16 milliseconds of time that the browser (and whatever javascript you may be running) have, to figure out  get a page ready for display. Especially on low-powered mobile devices, every one of those milliseconds is precious. 
	</aside>
</section>

<section>
	<img src="" alt="A screenshot of smashingconf.com with the dev tools open" />
	5ms median / 
	<aside class="notes">
Let me give you a high-level sense of what that number means... My computer is not a low-powered mobile device, it‚Äôs a 15" macbook pro.

And when I load a fairly simple, well-architected, responsive page that uses media queries, like, say SmashingConf.com, and measure the perf of the site while I resize the window a bunch, I can drill down with the dev tools and see that, most of these frames are happening right on schedule at 60FPS. And most of that time is idle, too ‚Äì¬†the browser is spending about 4-5 ms re-figuring layout and re-painting in response to the changing window size, but it has 10ms to spare.

We do actually drop a couple of frames every once and a while -- it looks here like I hit a major breakpoint right at the end of a 16ms beat, and the browser had to spend 17ms calculating and painting the new, significantly different layout... bad luck, but, still, visually nearly seamless.

So that gives you some sense of the time scales and headroom involved here. Now, let‚Äôs think about container queries.
	</aside>
</section>

<section>
<object>
	diagram
</object>
<aside class="notes">
Here's our pipeline again.

Even if we've figured out how to prevent infinite loops, and even if we re-architect browsers to be able to walk backwards, to do *a* loop ‚Äì container queries, fundamentally, require taking one or more trips around the loop. Basing styles on styles and layout on layout is literally the whole point.

Every trip around the loop takes time. And if we start using container queries as liberally as we use media queries, today ‚Äì¬†container-querying all the things and especially nesting container queried components within container-queried components ‚Äì¬†we might be taking dozens or even hundreds of trips around the loop, each frame.

That's bad for users.
</aside>
</section>

<section>
<img src="" alt="EQCSS homepage screenshot" />
<aside class="notes">
I‚Äôve already mentioned one polyfill ‚Äì¬†Martin Auswoger‚Äôs cq-prolyfill ‚Äì¬†here‚Äôs another: Tommy Hodgin‚Äôs EQCSS. Tommy has done more work than anyone, anywhere, advocating for Container Queries. He‚Äôs built this pollyfill, stuffed it with features, and is amassing a frankly staggering library of demos. So I asked him for his worst-performing demo.
</aside>
</section>

<section>
<img src="" alt="EQCSS homepage screenshot" />
<aside class="notes">
He kindly sent me this pricing comparison chart. And when I resize this, well, it's not pretty. The worst frames here are taking an order of magnitude more time than browsers like them to -- 150ms -- we‚Äôre missing ten frames in a row, here. Often. If you drill down and look what‚Äôs taking all of that time, Chrome Dev Tools shows you all of these little purple layout boxes with bright red corners, signifying forced reflows that the plugin needed to do as part of its container-querying-work. Each one is a small trip around the element-query loop for some subtree of the page.
</aside>
</section>


<section>
<blockquote class="twitter-tweet" data-conversation="none"  data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/_lemonmade">@_lemonmade</a> <a href="https://twitter.com/snookca">@snookca</a> Any insight into why Shopify moved away from JS-based container queries in the admin? FoUC, or?</p>&mdash; Eric Portis (@etportis) <a href="https://twitter.com/etportis/status/870280168413085696">June 1, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">We had problems with forced reflows and layout thrashing, especially on page load. It was probably partially our implementation of them tho.</p>&mdash; Dominic McPhee (@dfmcphee) <a href="https://twitter.com/dfmcphee/status/870458614842105856">June 2, 2017</a></blockquote>

<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">But were they ever a joy to use. I miss them.</p>&mdash; Scott Vinkle (@svinkle) <a href="https://twitter.com/svinkle/status/870462425199497216">June 2, 2017</a></blockquote>

<aside class="notes">
And indeed - bad performance is what killed what was, to my knowledge, the first big production implementation of container queries. [Jonathan Snook] Shopify implemented a javascript-based form of container queries on their admin pages three years ago, but have since moved entirely away from them.

I asked why and got this pair of responses, which is just about perfect.

They were too slow. But boy do we miss them.
</aside>
</section>

<section class="title">
<p>Paths forward</p>
<aside class="notes">
I'm happy to report that some very, very smart people have some very good ideas and are actively working on pieces of the puzzle.
</aside>
</section>

<section>
<h1>Containment</h1>
<p>to the rescue?</p>
<aside class="notes">
The first puzzle piece, we've already mentioned, actually. CSS Containment, in addition to getting us out of the infinite container query loop problem, may actually help offset some of the speed penalties inherent to container queries, too. When we prevent children from being able to influence the size or style of their parents, turns out, we can usefuly paralellize and optimize a bunch of layout work. So perhaps, a solution that brought a lot of both container queries but also layout containment to the web, wouldn't be so bad for layout performance after all.

I haven‚Äôt done a lot of testing here myself, but Paul Lewis published an example when the contain property landed in Chrome, wherein the layout time for a page dropped from 50-something ms down to 0.05ms, all because of this one weird CSS property.

https://developers.google.com/web/updates/2016/06/css-containment

Seems promising?
</aside>
</section>

<section>
<h1>Asynchronicity</h1>
<p>Knock. there? Async container queries Who‚Äôs knock!</p>
<aside class="notes">
The second idea: make sure that, even if our container querying is slow, we minimize the damage that we‚Äôre doing to users‚Äô experiences by doing the work asynchronously.

Browsers respond to Media Queries synchronously. Which is to say, immediately after a media query toggles between true and false, the browser‚Äôs entire world stops for as long as it needs to so that it can respond to the change.

If we can't make container queries as performant as media queries, perhaps we can make them a little less world-stopping. We can let the browser re-schedule container query work, or even move it to another thread, so that we can continue to keep the rest of the user‚Äôs experience from feeling "stalled" or "stuck".

I‚Äôm happy to report that there‚Äôs a working implementation of this idea too, behind a flag in Chrome: 
</aside>
</section>

<section>
<h1>ResizeObserver</h1>
<aside class="notes">
ResizeObserver.

The more I learn about ResizeObserver, the more I love it. It‚Äôs a purpose-built Container Query toolkit.

First and foremost, it lets you attach resize event listeners directly to elements. The current batch of prolyfills have to listen to a whole bunch of possibly-related events ‚Äì‚Äì like window resizes and DOM changes -- and then check to see if any element resizing actually happened.

ResizeObserver also provides access to a stripped-down set of very-cheap-to-query element geometry that the browser is already maintaining. Current prolyfills all have to make extensive use of element.getComputedStyles, which forces a reflow to insure that the queried styles are up-to-date. ResizeObserver gives you access to fresh element geometry far more cheaply.

Next up is what we started with: asynchronusness. The callbacks that you register with ResizeObserver are treated as what browsers call "microtasks." Which means that the browser doesn‚Äôt drop everything and run them on the main thread as soon as a resize happens. Instead, they're batched up and run at a precise, later time: just after the next layout and just before the next paint. This is really important, actually. It ensures that you're not doing any work too early -- you're not going to be surprised by any additional layout changes that you weren't expecting -- or too late -- the browser will wait and paint when you're done. Most importantly, batched-up asynchronous callbacks don‚Äôt interrupt or forestall any other super-important intra-frame work - like, say, responding to user input.

Oh! And! ResizeObserver also features a smart way to deal with infinite loops. Because we're in Javascript land, it *can't* keep you from creating infinite layout‚Üíresponse‚Üílayout‚Üíresponse‚Üílayout‚Üíresponse loops. But it does use a thoughtful strategy ‚Äì¬†based on nesting-levels - to make sure that it breaks out of those loops in sensible ways in order to paint once a frame.

You've already seen examples of that. This slide deck, the one right in front of you now, is running a simple, ResizeObserver-based container-query implementation that I slapped together for the purposes of this talk. All of the looping examples that I've shown you flicker between states exactly once per frame, without freezing, stuttering, throwing a call stack exception, or preventing me from scrolling or otherwise interacting with the page, because they were built with ResizeObserver.

In short, ResizeObserver -- especially when combined with explicit style containment -- might give us everything that we need to implement smart, as-performant-as-possible container queries -- in JavaScript.

But, of course, we want to use them in CSS.

Which brings me to the last big idea that the smartest spec and browser folks in the world have about how to solve Container Queries. It's where we come in.
</aside>
</section>

<section>
<h1>Houdini</h1>
<aside class="notes">
How many of you have heard of Houdini?
</aside>
</section>



<section>
<h1>Prolyfills</h1>
<p>cq-prollyfill, eqcss</p>
</section>

<section>
<h1>Syntax!</h1>
<ul>
	<li>hacks...
	<li>Pseudo-selector
	<li>@ rules?
	<li>generalized conditionals for css
</ul>
</section>


<section>
<h1>What can you do?</h1>
<p>If you know some C and have been looking to get your hands dirty</p>
<aside class="notes">
Authors who are actually going to use the thing
Spec editors who can specify it
Browser vendors who are willing + able to implement it
	- Yoav took the RICG over the line with responsive images, took a deep dive into performance, networking, and resource loading
	- Layout engine is another dragon. The web needs another knight in shining armor.

</aside>
</section>



</body>
</html>